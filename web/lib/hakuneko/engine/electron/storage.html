<link rel="import" href="../base/storage.html">

<script>

    /**
     *
     */
    class StorageElectron extends StorageBase {

        /**
         *
         */
        constructor() {
            super();
            let electron = require( 'electron' );
            this.dialog = electron.remote.dialog;
            this.platform = electron.remote.process.platform;
            this.exec = electron.remote.require( 'child_process' ).exec;
            this.jszip = electron.remote.require( 'jszip' );
            this.fs = require( 'fs' );
            this.path = require( 'path' );
            this.config = this.path.join( electron.remote.require( './config.js' ).app.userdata, 'hakuneko.' );
            this.temp = this.path.join( require('os').tmpdir(), 'hakuneko' );
            this._createDirectoryChain( this.temp );

            this.fileURISubstitutions = {
                rgx: /['#\?]/g,
                map: {
                    '\'': '%27',
                    '#': '%23',
                    '?': '%3F',
                }
            };
        }

        /**
         * Save the given value for the given key in the persistant storage
         */
        saveConfig( key, value ) {
            // NOTE: use the browsers promise implementation instead of HakuNeko's obsoltete promise implementation
            return new window.Promise( ( resolve, reject ) => {
                this.fs.writeFile( this.config + key, JSON.stringify( value ), function( error ) {
                    if( error ) {
                        reject( error );
                    } else {
                        resolve();
                    }
                } );
            } );
        }

        /**
         * Load the value for the given key from the persistant storage
         */
        loadConfig( key ) {
            // NOTE: use the browsers promise implementation instead of HakuNeko's obsolete promise implementation
            return new window.Promise( ( resolve, reject ) => {
                this.fs.readFile( this.config + key, 'utf8', ( error, data ) => {
                    try {
                        if( error ) {
                            throw error;
                        }
                        resolve( JSON.parse( data ) );
                    } catch( e ) {
                        reject( e );
                    }
                } );
            } );
        }

        /**
         * Convenience function wrapping key value saving for mangas collection
         */
        saveMangaList( connectorID, mangas, callback ) {
            this.saveConfig( 'mangas.' + connectorID, mangas )
            .then( () => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( null );
                }
            } )
            .catch( error  => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( error );
                }
            } );
        }

        /**
         * Convenience function wrapping key value loading for mangas collection
         */
        loadMangaList( connectorID, callback ) {
            this.loadConfig( 'mangas.' + connectorID )
            .then( data => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( data, null );
                }
            } )
            .catch( error => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( undefined, error );
                }
            } );
        }

        /**
         * https://github.com/electron/electron/blob/master/docs/api/dialog.md
         */
        folderBrowser( rootPath ) {
            let directory = this.dialog.showOpenDialog( {
                title: 'Download Directory for Mangas',
                //message: 'MESSAGE',
                defaultPath: rootPath,
                properties: ['openDirectory']
            });
            return ( directory && directory.length > 0 ? directory[0] : rootPath );
        }

        /**
         * Check if the corresponding manga directory exist.
         * Due to performance this method must not be used for bulk existing checks.
         */
        mangaDirectoryExist( manga, callback ) {
            this.fs.stat(this._mangaOutputPath( manga ), ( error, stats ) => {
                if( !error && stats.isDirectory() ) {
                    callback( null, true );
                } else {
                    callback( error, false );
                }
            });
        }

        /**
         * Find all directories/files in the base directory.
         * This key-value map can than be used to look up for existing manga titles (where the key represents the title and the value is always true).
         * Keep in mind that the manga titles in this map are sanitized and may not equal the raw (original) manga title.
         */
        getExistingMangaTitles( connector, callback ) {
            let directory = this._connectorOutputPath( connector );
            this.fs.readdir( directory, ( error, entries ) => {
                let titleMap = [];
                if( !error ) {
                    // use key value pairs instead of plain titles to increase performance when looking up a certain manga title
                    entries.forEach( ( title ) => {
                        titleMap[title] = true;
                    });
                }
                callback( error, titleMap );
            });
        }

        /**
         * Find all directories/files in the manga directory.
         * This list can than be used to look for existing chapter titles.
         * Keep in mind that the chapter titles in this list are sanitized and may not equal the raw (original) chapter title.
         */
        getExistingChapterTitles( manga, callback ) {
            let directory = this._mangaOutputPath( manga );
            this.fs.readdir( directory, ( error, entries ) => {
                let titleMap = [];
                if( !error ) {
                    // TODO: only add supported files / folders
                    // file that ends with any of the supported extension,
                    // folders that not ends with m3u8
                    // folders that contains m3u8?
                    // folders that contains any image?
                    /*
                    entries = entries.filter( ( path ) => {
                        return (
                            path.endsWith( EpisodeFormat.m3u8 ) || 
                            path.endsWith( EpisodeFormat.mkv ) ||
                            path.endsWith( ChapterFormat.epub ) ||
                            path.endsWith( ChapterFormat.cbz ) ||
                            path.endsWith( ChapterFormat.pdf )
                            // what about directory with images ???
                        );
                    } );
                    */
                    // use key value pairs instead of plain titles to increase performance when looking up a certain manga title
                    entries.forEach( ( title ) => {
                        titleMap[title] = true;
                    });
                }
                callback( error, titleMap );
            });
        }

        /**
         * ...
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        loadChapterPages( chapter ) {
            let path = this._chapterOutputPath( chapter );
            if( path.endsWith( EpisodeFormat.m3u8 ) ) {
                return this._loadEpisodeM3U8( path );
            }
            if( path.endsWith( EpisodeFormat.mkv ) ) {
                return this._loadEpisodeMKV( path );
            }
            if( path.endsWith( ChapterFormat.epub ) ) {
                return this._loadChapterPagesEPUB( path );
            }
            if( path.endsWith( ChapterFormat.pdf ) ) {
                return this._loadChapterPagesPDF( path );
            }
            if( path.endsWith( ChapterFormat.cbz ) ) {
                return this._loadChapterPagesCBZ( path );
            }
            return this._loadChapterPagesFolder( path );
        }

        /**
         * 
         */
        _loadEpisodeM3U8( directory ) {
            return ( new Promise( ( resolve, reject ) => {
                this.fs.readdir( directory, ( error, files ) => {
                    if( error ) {
                        reject( error );
                    } else {
                        resolve( files );
                    }
                } );
            } ) )
            .then( files => {
                let playlist = files.find( file => file.endsWith( EpisodeFormat.m3u8 ) );
                let subtitles = files.filter( file => file.endsWith( '.ass' ) || file.endsWith( '.ssa' ) );
                let media = {
                    playlist: this._makeValidFileURL( directory, playlist ),
                    subtitles: subtitles.sort().map( subtitle => {
                        let parts = subtitle.split( '.' );
                        return {
                            format: parts[parts.length-1],
                            locale: parts[parts.length-2],
                            url: this._makeValidFileURL( directory, subtitle ),
                            content: this.fs.readFileSync( this.path.join( directory, subtitle ), { encoding: 'utf-8' } )
                        };
                    } )
                };
                return Promise.resolve( media );
            } );
        }

        /**
         * 
         */
        _loadEpisodeMKV( matroska ) {
            // TODO: load subtitles
            let media = {
                video: this._makeValidFileURL( matroska, '' ),
                subtitles: []
            }
            return Promise.resolve( media );
        }

        /**
         * Return a promise with the loaded opened zip archive data
         */
        _openZipArchive( file ) {
            return new Promise( ( resolve, reject ) => {
                this.fs.readFile( file, ( error, data ) => {
                    if( error ) {
                        reject( error );
                    } else {
                        resolve( data );
                    }
                } );
            } )
            .then( data => {
                let zip = new JSZip();
                return zip.loadAsync( data, {} );
            } );
        }

        /**
         * Extract file from zip entry to temp and returns a promise that
         * will be resolved with the URI to the extracted file.
         */
        _extractZipEntry( archive, file ) {
            return archive.files[file].async( 'uint8array' )
            .then( data => {
                let name = this.path.join( this.temp, this.path.basename( file ) );
                // attach timestamp to force reload of already existing, but overwritten temp files
                let page = encodeURI( 'file://' + name.replace(/\\/g, '/') + '?ts=' + Date.now() );
                return new Promise( ( resolve, reject ) => {
                    this.fs.writeFile( name, data, error => {
                        if( error ) {
                            reject( error );
                        } else {
                            resolve( page );
                        }
                    } );
                } );
            } );
        }

        /**
         * Read image data from e-book.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesEPUB( ebook ) {
            return this._openZipArchive( ebook )
            .then( archive => {
                let promises = Object.keys( archive.files ).filter( file => {
                    return /^OEBPS[/\\]img[/\\][^/\\]+$/.test( file );
                } ).map( file => {
                    return this._extractZipEntry( archive, file );
                } );
                return Promise.all( promises );
            } )
            .then( pages => {
                return Promise.resolve( pages.sort() );
            } );
        }

        /**
         * Read image data from portable document format.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesPDF( pdf ) {
            return Promise.reject( new Error( 'PDF preview not yet supported!' ) );
        }

        /**
         * Read image data from CBZ archive.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesCBZ( cbz ) {
            return this._openZipArchive( cbz )
            .then( archive => {
                let promises = Object.keys( archive.files ).filter( file => {
                    return /^[^/\\]+$/.test( file );
                } ).map( file => {
                    return this._extractZipEntry( archive, file );
                } );
                return Promise.all( promises );
            } )
            .then( pages => {
                return Promise.resolve( pages.sort() );
            } );
        }

        /**
         * Read image data from directory.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesFolder( directory, callback ) {
            return ( new Promise( ( resolve, reject  ) => {
                this.fs.readdir( directory, ( error, files ) => {
                    if( error ) {
                        reject( error );
                    } else {
                        resolve( files );
                    }
                } );
            } ) )
            .then( files => {
                let pages = files.map( file => this._makeValidFileURL( directory, file ) );
                return Promise.resolve( pages );
            } );
        }

        /**
         * 
         */
        _makeValidFileURL( directory, file ) {
            return encodeURI( 'file://' + this.path.join( directory, file ).replace( /\\/g, '/' ) )
            // some special cases are not covered with encodeURI and needs to be replaced manually
            .replace( this.fileURISubstitutions.rgx, m => this.fileURISubstitutions.map[m] );
        }

        /**
         * Save the pages of the given chapter.
         * The given content is a list of raw data for each corresponding page in the chapter.
         * The storage decides depending on the engine and available settings where the pages will be stored!
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         * 
         * content is an array of blobs
         */
        saveChapterPages( chapter, content ) {
            try {
                let pageData = content.map( ( page, index ) => {
                    return {
                        name: this._pageFileName( index + 1, page.type ),
                        type: page.type,
                        data: page
                    }
                });
                let output = this._chapterOutputPath( chapter );

                if( Engine.Settings.chapterFormat.value === ChapterFormat.img ) {
                    this._createDirectoryChain( output );
                    return this._saveChapterPagesFolder( output, pageData );
                }
                if( Engine.Settings.chapterFormat.value === ChapterFormat.cbz ) {
                    this._createDirectoryChain( this.path.dirname( output ) );
                    return this._saveChapterPagesCBZ( output, pageData );
                }
                if( Engine.Settings.chapterFormat.value === ChapterFormat.pdf ) {
                    this._createDirectoryChain( this.path.dirname( output ) );
                    return this._saveChapterPagesPDF( output, pageData );
                }
                if( Engine.Settings.chapterFormat.value === ChapterFormat.epub ) {
                    this._createDirectoryChain( this.path.dirname( output ) );
                    return this._saveChapterPagesEPUB( output, pageData );
                }

                throw new Error( 'Unsupported output format: ' + Engine.Settings.chapterFormat.value );
            } catch( error ) {
                Promise.reject( error );
            }
        }

        /**
         * Create and save pages to the given e-book file.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesEPUB( ebook, pageData ) {
            let zip = new JSZip();
            zip.file( 'mimetype', EbookGenerator.createMimetype() );
            zip.folder( 'META-INF' ).file( 'container.xml', EbookGenerator.createContainerXML() );
            let oebps = zip.folder('OEBPS');
            oebps.folder( 'css' ).file( 'style.css', EbookGenerator.createStyleCSS() );
            let img = oebps.folder( 'img' );
            let xhtml = oebps.folder( 'xhtml' );
            let params = [];
            pageData.forEach( ( page, index ) => {
                img.file( page.name, page.data );
                xhtml.file( index + '.xhtml', EbookGenerator.createPageXHTML( page.name ) );
                params.push({
                    img: page.name,
                    xhtml: index + '.xhtml',
                    mime: page.type
                } );
            } );
            let uid = btoa( encodeURIComponent( ebook ) ).replace(/[^a-zA-Z]/g, '');
            let title = `${this.path.basename( this.path.dirname( ebook ) )} ${this.path.sep} ${this.path.basename( ebook, ChapterFormat.epub )}`;
            oebps.file( 'content.opf', EbookGenerator.createContentOPF( uid, title, params ) );
            oebps.file( 'toc.ncx', EbookGenerator.createTocNCX( uid, '', params ) );
            return zip.generateAsync( { compression: 'STORE', type: 'uint8array' } )
            .then( data => {
                return this._writeFile( ebook, data );
            } );
        }

        /**
         * Create and save pages to the given portable document file.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesPDF( pdf, pageData ) {
            let doc = new jspdf()
            doc.deletePage(1);
            return this._addImagesToPDF( doc, pageData )
            .then( () => {
                let data = new Uint8Array( doc.output( 'arraybuffer' ) );
                return this._writeFile( pdf, data );
            } );
        }

        /**
         * Add all images as PDF pages to the given document.
         */
        _addImagesToPDF( pdfDocument, pageData, pageIndex ) {
            if( typeof( pageIndex ) !== 'number' ) {
                pageIndex = 0;
            }
            if( pageIndex < 0 ) {
                return Promise.reject( new Error( 'PDF page index out of range: ' + pageIndex ) );
            }
            if( pageIndex >= pageData.length ) {
                return Promise.resolve();
            }
            return this._addImageToPDF( pdfDocument, pageData[pageIndex] )
            .then( () => {
                return this._addImagesToPDF( pdfDocument, pageData, pageIndex+1 )
            } );
        }

        /**
         * Add a single image as PDF page to the given document.
         */
        _addImageToPDF( pdfDocument, page ) {
            return createImageBitmap( page.data )
            .then( bitmap => {
                let promise;
                let pdfImgType = this._pdfImageType( page.type );
                if( !pdfImgType ) {
                    pdfImgType = 'JPEG';
                    let canvas = document.createElement( 'canvas' );
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    let ctx = canvas.getContext( '2d' );
                    ctx.drawImage( bitmap, 0, 0 );
                    promise = new Promise( ( resolve, reject ) => {
                        canvas.toBlob( data => {
                            resolve( data );
                        }, 'image/jpeg', 0.90 );
                    } );
                } else {
                    promise = Promise.resolve( page.data );
                }
                return promise.then( blob => {
                    return this._blobToBytes( blob )
                    .then( bytes => {
                        try {
                            pdfDocument.addPage( bitmap.width, bitmap.height );
                            // use page.name as image alias, to prevent image repeat bug: https://github.com/MrRio/jsPDF/issues/998
                            pdfDocument.addImage( bytes, pdfImgType, 0, 0, bitmap.width, bitmap.height, page.name );
                            return Promise.resolve();
                        } catch( error ) {
                            return Promise.reject( error );
                        }
                    } );
                } )
            } );
        }

        /**
         * Create and save pages to the given archive file.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesCBZ( archive, pageData ) {
            let zip = new JSZip();
            pageData.forEach( page => {
                zip.file( page.name, page.data );
            } );
            return zip.generateAsync( { compression: 'STORE', type: 'uint8array' } )
            .then( data => {
                return this._writeFile( archive, data );
            } );
        }

        /**
         * Save pages to the given directory.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesFolder( directory, pageData ) {
            let promises = pageData.map( page => {
                return this._blobToBytes( page.data )
                .then( data => {
                    return this._writeFile( this.path.join( directory, page.name ), data );
                } )
            } );
            return Promise.all( promises );
        }

        /**
         * Helper function to convert a Blob to an Uint8Array
         * https://github.com/electron/electron/blob/master/docs/api/protocol.md#protocolregisterbufferprotocolscheme-handler-completion
         */
         _blobToBytes( blob ) {
            return new Promise( ( resolve, reject ) => {
                let reader = new FileReader();
                reader.onload = event => {
                    // NOTE: Uint8Array() seems slightly better than Buffer.from(), but both are blazing fast
                    resolve( new Uint8Array( event.target.result ) );
                    //resolve( Buffer.from( event.target.result ) );
                };
                reader.onerror = event => {
                    reject( event.target.error );
                }
                reader.readAsArrayBuffer( blob );
            } );
        }

        /**
         * Wrap the async write file function into a promise
         */
        _writeFile( path, data ) {
            return new Promise( ( resolve, reject ) => {
                this.fs.writeFile( path, data, error => {
                    if( error ) {
                        reject( error );
                    } else {
                        resolve();
                    }
                } );
            } );
        }

        /**
         * Store a file directly in the chapter directory
         */
        saveChapterFileM3U8( chapter, content, callback ) {
            let file = this._mangaOutputPath( chapter.manga );
            file = this.path.join( file, this.sanatizePath( chapter.title + EpisodeFormat.m3u8 ) );
            this._createDirectoryChain( file );
            file = this.path.join( file, this.sanatizePath( content.name ) );
            this.fs.writeFile( file, content.data, function( error ) {
                callback( error );
            });
        }

        /**
         * Multiplex chapter playlist/streams using the given ffmpeg command (without output format & file!).
         * The chapter directory is the working directory, and will be deleted after muxing.
         * The output file will be stored directly in the manga directory.
         */
        muxPlaylistM3U8( chapter, ffmpeg, callback ) {
            let directory = this._mangaOutputPath( chapter.manga );
            this._createDirectoryChain( directory );
            let file = this.path.join( directory, this.sanatizePath( chapter.title + EpisodeFormat.mkv ) );
            directory = this.path.join( directory, this.sanatizePath( chapter.title + EpisodeFormat.m3u8 ) );
            ffmpeg += ' -f matroska -y "' + file + '"';
            this.exec( ffmpeg, { cwd: directory, windowsHide: true }, callback );
        }

        /**
         * Helper function to generate the path where the connector mangas are stored.
         */
        _connectorOutputPath( connector ) {
            let output = Engine.Settings.baseDirectory.value;
            if( Engine.Settings.useSubdirectory.value ) {
                output = this.path.join( output, this.sanatizePath( connector.label ) );
            }
            return output;
        }

        /**
         * Helper function to generate the path where the manga chapters are stored.
         */
        _mangaOutputPath( manga ) {
            let output = this._connectorOutputPath( manga.connector );
            output = this.path.join( output, this.sanatizePath( manga.title ) );
            return output;
        }

        /**
         * Helper function to generate the path where the chapter pages are stored.
         */
        _chapterOutputPath( chapter ) {
            let output = this._mangaOutputPath( chapter.manga );
            output = this.path.join( output, this.sanatizePath( chapter.title ) );
            if( chapter.status === DownloadStatus.offline ) {
                return output;
            }
            // only valid for loading anime episodes, ignored when save pages
            if( this.fs.existsSync( output + EpisodeFormat.m3u8 ) ) {
                return output + EpisodeFormat.m3u8;
            }
            // only valid for loading anime episodes, ignored when save pages
            if( this.fs.existsSync( output + EpisodeFormat.mkv ) ) {
                return output + EpisodeFormat.mkv;
            }
            // used when loading and saving manga chapters
            if( Engine.Settings.chapterFormat.value !== ChapterFormat.img ) {
                output += Engine.Settings.chapterFormat.value;
            }
            return output;
        }

        /**
         * Helper function to recursively create all non-existing folders of the given path.
         */
        _createDirectoryChain( path ) {
            if( this.fs.existsSync( path ) || path === this.path.parse( path ).root ) {
                return;
            }
            this._createDirectoryChain( this.path.dirname( path ) );
            this.fs.mkdirSync( path, '0755', true );
        }

        /**
         * Create a path without forbidden characters.
         * Based on HakuNeko legacy for backward compatibility to detect existing mangas/chapters.
         * LINUX: wxT("/\r\n\t");
         * WINDOWS: wxT("\\/:*?\"<>|\r\n\t");
         */
        sanatizePath ( path ) {
            if( this.platform.indexOf( 'win' ) === 0 ) {
                // TODO: max. 260 characters per path
                path = path.replace( /[\\\/\:\*\?\"\<\>\|\r\n\t]/g, '' );
                return path.replace( /\.+$/g, '' ).trim(); // remove trailing dots and whitespaces
            }
            if( this.platform.indexOf( 'linux' ) === 0 ) {
                return path.replace( /[\/\r\n\t]/g, '' );
            }
            if( this.platform.indexOf( 'darwin' ) === 0 ) {
                // TODO: max. 32 chars per part
                return path.replace( /[\/\:\r\n\t]/g, '' );
            }
            return path;
        }

        /**
         * Helper function to generate an entry name for a page (picture) depending on the given number and mime type
         */
        _pageFileName( number, mimeType ) {
            let fileName = ( '00' + number ).slice( -3 );
            if( mimeType.indexOf( 'image/webp' ) > -1 ) {
                return fileName + '.webp';
            }
            if( mimeType.indexOf( 'image/jpeg' ) > -1 ) {
                return fileName + '.jpg';
            }
            if( mimeType.indexOf( 'image/png' ) > -1 ) {
                return fileName + '.png';
            }
            if( mimeType.indexOf( 'image/gif' ) > -1 ) {
                return fileName + '.gif';
            }
            if( mimeType.indexOf( 'image/bmp' ) > -1 ) {
                return fileName + '.bmp';
            }
            if( mimeType.indexOf( 'image/' ) > -1 ) {
                return fileName + '.img';
            }
            return fileName + '.bin';
        }

        /**
         * Helper function to get the mime type depending on the file extension of the given file name.
         */
        _pageFileMime( file ) {
            let extension = this.path.extname( file );
            if( extension === '.webp' ) {
                return 'image/webp';
            }
            if( extension === '.jpeg' ) {
                return 'image/jpeg';
            }
            if( extension === '.jpg' ) {
                return 'image/jpeg';
            }
            if( extension === '.png' ) {
                return 'image/png';
            }
            if( extension === '.gif' ) {
                return 'image/gif';
            }
            if( extension === '.bmp' ) {
                return 'image/bmp';
            }
            if( extension === '.img' ) {
                return 'image/';
            }
            return 'application/octet-stream';
        }

        /**
         * Helper function to get the image type for jsPDF of the given mime type.
         * If the mime is not a spported PDF image format undefined will be returned.
         */
        _pdfImageType( mime ) {
            if( mime === 'image/jpeg' ) {
                return 'JPEG';
            }
            if( mime === 'image/png' ) {
                return 'PNG';
            }
            return undefined;
        }
    }

</script>