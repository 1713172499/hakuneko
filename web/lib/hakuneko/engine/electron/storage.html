<link rel="import" href="../base/storage.html">

<script>

    /**
     *
     */
    class StorageElectron extends StorageBase {

        /**
         *
         */
        constructor() {
            super();
            let electron = require( 'electron' );
            this.dialog = electron.remote.dialog;
            this.platform = electron.remote.process.platform;
            this.exec = electron.remote.require( 'child_process' ).exec;
            this.jszip = electron.remote.require( 'jszip' );
            this.fs = require( 'fs' );
            this.path = require( 'path' );
            this.config = this.path.join( electron.remote.require( './config.js' ).app.userdata, 'hakuneko.' );
            this.temp = this.path.join( require('os').tmpdir(), 'hakuneko' );
            this._createDirectoryChain( this.temp );

            this.fileURISubstitutions = {
                rgx: /['#\?]/g,
                map: {
                    '\'': '%27',
                    '#': '%23',
                    '?': '%3F',
                }
            };
        }

        /**
         * Save the given value for the given key in the persistant storage
         */
        saveConfig( key, value ) {
            // NOTE: use the browsers promise implementation instead of HakuNeko's obsoltete promise implementation
            return new window.Promise( ( resolve, reject ) => {
                this.fs.writeFile( this.config + key, JSON.stringify( value ), function( error ) {
                    if( error ) {
                        reject( error );
                    } else {
                        resolve();
                    }
                } );
            } );
        }

        /**
         * Load the value for the given key from the persistant storage
         */
        loadConfig( key ) {
            // NOTE: use the browsers promise implementation instead of HakuNeko's obsolete promise implementation
            return new window.Promise( ( resolve, reject ) => {
                this.fs.readFile( this.config + key, 'utf8', ( error, data ) => {
                    try {
                        if( error ) {
                            throw error;
                        }
                        resolve( JSON.parse( data ) );
                    } catch( e ) {
                        reject( e );
                    }
                } );
            } );
        }

        /**
         * Convenience function wrapping key value saving for mangas collection
         */
        saveMangaList( connectorID, mangas, callback ) {
            this.saveConfig( 'mangas.' + connectorID, mangas )
            .then( () => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( null );
                }
            } )
            .catch( error  => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( error );
                }
            } );
        }

        /**
         * Convenience function wrapping key value loading for mangas collection
         */
        loadMangaList( connectorID, callback ) {
            this.loadConfig( 'mangas.' + connectorID )
            .then( data => {
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( data, null );
                }
            } )
            .catch( error => {
                //if( typeof( callback ) === typeof( Function ) ) {
                //    callback( undefined, error );
                //}
                console.log( 'Migrating "mangas.' + connectorID + '" from indexedDB to persistant storage ...' );
                // [OBSOLETE] This call is only available for migration from indexedDB to persistant storage
                // >>>
                // can be removed in the next release > 0.3.1
                this.loadFromDB( 'mangas', connectorID, ( mangas, error ) => {
                    if( typeof( callback ) === typeof( Function ) ) {
                        callback( mangas, error );
                    }
                    this.saveConfig( 'mangas.' + connectorID, mangas )
                        .catch( error => {
                            console.warn( 'Failed to copy "mangas.' + connectorID + '" from indexedDB into persistant storage', error );
                            alert( 'Failed to copy your mangas to the new persistant storage.\nIt would be helpful if you report this problem along with the console output.\n\nhttps://sourceforge.net/p/hakuneko/discussion/support/' );
                        } );
                } );
                // <<<
            } );
            
        }

        /**
         * https://github.com/electron/electron/blob/master/docs/api/dialog.md
         */
        folderBrowser( rootPath ) {
            let directory = this.dialog.showOpenDialog( {
                title: 'Download Directory for Mangas',
                //message: 'MESSAGE',
                defaultPath: rootPath,
                properties: ['openDirectory']
            });
            return ( directory && directory.length > 0 ? directory[0] : rootPath );
        }

        /**
         * Check if the corresponding manga directory exist.
         * Due to performance this method must not be used for bulk existing checks.
         */
        mangaDirectoryExist( manga, callback ) {
            this.fs.stat(this._mangaOutputPath( manga ), ( error, stats ) => {
                if( !error && stats.isDirectory() ) {
                    callback( null, true );
                } else {
                    callback( error, false );
                }
            });
        }

        /**
         * Find all directories/files in the base directory.
         * This key-value map can than be used to look up for existing manga titles (where the key represents the title and the value is always true).
         * Keep in mind that the manga titles in this map are sanitized and may not equal the raw (original) manga title.
         */
        getExistingMangaTitles( connector, callback ) {
            let directory = this._connectorOutputPath( connector );
            this.fs.readdir( directory, ( error, entries ) => {
                let titleMap = [];
                if( !error ) {
                    // use key value pairs instead of plain titles to increase performance when looking up a certain manga title
                    entries.forEach( ( title ) => {
                        titleMap[title] = true;
                    });
                }
                callback( error, titleMap );
            });
        }

        /**
         * Find all directories/files in the manga directory.
         * This list can than be used to look for existing chapter titles.
         * Keep in mind that the chapter titles in this list are sanitized and may not equal the raw (original) chapter title.
         */
        getExistingChapterTitles( manga, callback ) {
            let directory = this._mangaOutputPath( manga );
            this.fs.readdir( directory, ( error, entries ) => {
                let titleMap = [];
                if( !error ) {
                    // TODO: only add supported files / folders
                    // file that ends with any of the supported extension,
                    // folders that not ends with m3u8
                    // folders that contains m3u8?
                    // folders that contains any image?
                    /*
                    entries = entries.filter( ( path ) => {
                        return (
                            path.endsWith( EpisodeFormat.m3u8 ) || 
                            path.endsWith( EpisodeFormat.mkv ) ||
                            path.endsWith( ChapterFormat.epub ) ||
                            path.endsWith( ChapterFormat.cbz ) ||
                            path.endsWith( ChapterFormat.pdf )
                            // what about directory with images ???
                        );
                    } );
                    */
                    // use key value pairs instead of plain titles to increase performance when looking up a certain manga title
                    entries.forEach( ( title ) => {
                        titleMap[title] = true;
                    });
                }
                callback( error, titleMap );
            });
        }

        /**
         * ...
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        loadChapterPages( chapter, callback ) {
            let path = this._chapterOutputPath( chapter );
            if( path.endsWith( EpisodeFormat.m3u8 ) ) {
                return this._loadEpisodeM3U8( path, callback );
            }
            if( path.endsWith( EpisodeFormat.mkv ) ) {
                return this._loadEpisodeMKV( path, callback );
            }
            if( path.endsWith( ChapterFormat.epub ) ) {
                return this._loadChapterPagesEPUB( path, callback );
            }
            if( path.endsWith( ChapterFormat.pdf ) ) {
                return this._loadChapterPagesPDF( path, callback );
            }
            if( path.endsWith( ChapterFormat.cbz ) ) {
                return this._loadChapterPagesCBZ( path, callback );
            }
            this._loadChapterPagesFolder( path, callback );
        }

        /**
         * 
         */
        _loadEpisodeM3U8( directory, callback ) {
            this.fs.readdir( directory, ( error, files ) => {
                if( error ) {
                    return callback( error, undefined );
                }
                let playlist = files.find( ( file ) => {
                    return file.endsWith( EpisodeFormat.m3u8 );
                } );
                let subtitles = files.filter( ( file ) => {
                    return ( file.endsWith( '.ass' ) || file.endsWith( '.ssa' ) );
                } );
                let media = {
                    playlist: this._makeValidFileURL( directory, playlist ),
                    subtitles: subtitles.sort().map( subtitle => {
                        let parts = subtitle.split( '.' );
                        return {
                            format: parts[parts.length-1],
                            locale: parts[parts.length-2],
                            url: this._makeValidFileURL( directory, subtitle ),
                            content: this.fs.readFileSync( this.path.join( directory, subtitle ), { encoding: 'utf-8' } )
                        };
                    } )
                }
                callback( null, media );
            });
        }

        /**
         * 
         */
        _loadEpisodeMKV( matroska, callback ) {
            // TODO: load subtitles
            let media = {
                video: this._makeValidFileURL( matroska, '' ),
                subtitles: []
            }
            callback( null, media );
        }

        /**
         * Read image data from e-book.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesEPUB( ebook, callback ) {
            let errors = [];
            this.fs.readFile( ebook, ( function ( readingError, data ) {
                if( readingError ) {
                    errors.push( readingError );
                }
                let zip = new this.jszip();
                zip.loadAsync( data, {} ).then( ( unzip ) => {
                    let pages = [];
                    let timestamp = Date.now();
                    let promise = new Promise( () => {
                        callback( null, ( errors.length > 0 ? undefined : pages.sort() ) );
                    });
                    unzip.folder( 'OEBPS' ).folder( 'img' ).forEach( ( name, entry ) => {
                        let key = promise.defer();
                        name = this.path.join( this.temp, name );
                        entry.async( 'uint8array' ).then( ( data ) => {
                            this.fs.writeFile( name, data, function( writingError ) {
                                if( writingError ) {
                                    errors.push( writingError );
                                }
                                // attach timestamp to force reload of already existing, but overwritten temp files
                                pages.push( encodeURI( 'file://' + name.replace(/\\/g, '/') + '?ts=' + timestamp ) );
                                promise.resolve( key );
                            });
                        });
                    });
                });
            }).bind( this ) );
        }

        /**
         * Read image data from portable document format.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesPDF( pdf, callback ) {
            callback( new Error( 'PDF preview not yet supported!' ), undefined );
        }

        /**
         * Read image data from CBZ archive.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesCBZ( archive, callback ) {
            let errors = [];
            this.fs.readFile( archive, ( function ( readingError, data ) {
                if( readingError ) {
                    errors.push( readingError );
                }
                let zip = new this.jszip();
                zip.loadAsync( data, {} ).then( ( unzip ) => {
                    let pages = [];
                    let timestamp = Date.now();
                    let promise = new Promise( () => {
                        callback( null, ( errors.length > 0 ? undefined : pages.sort() ) );
                    });
                    unzip.forEach( ( name, entry ) => {
                        let key = promise.defer();
                        name = this.path.join( this.temp, name );
                        entry.async( 'uint8array' ).then( ( data ) => {
                            this.fs.writeFile( name, data, function( writingError ) {
                                if( writingError ) {
                                    errors.push( writingError );
                                }
                                // attach timestamp to force reload of already existing, but overwritten temp files
                                pages.push( encodeURI( 'file://' + name.replace(/\\/g, '/') + '?ts=' + timestamp ) );
                                promise.resolve( key );
                            });
                        });
                    });
                });
            }).bind( this ) );
        }

        /**
         * Read image data from directory.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured)
         * and a reference to the page list (undefined on error).
         */
        _loadChapterPagesFolder( directory, callback ) {
            this.fs.readdir( directory, ( error, files ) => {
                if( error ) {
                    return callback( error, undefined );
                }
                let pages = files.map( ( file ) => {
                    return this._makeValidFileURL( directory, file );
                } );
                callback( null, pages );
            });
        }

        /**
         * 
         */
        _makeValidFileURL( directory, file ) {
            return encodeURI( 'file://' + this.path.join( directory, file ).replace( /\\/g, '/' ) )
            // some special cases are not covered with encodeURI and needs to be replaced manually
            .replace( this.fileURISubstitutions.rgx, m => this.fileURISubstitutions.map[m] );
        }

        /**
         * Save the pages of the given chapter.
         * The given content is a list of raw data for each corresponding page in the chapter.
         * The storage decides depending on the engine and available settings where the pages will be stored!
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        saveChapterPages( chapter, content, callback ) {
            let pageData = content.map( ( page, index ) => {
                return {
                    name: this._pageFileName( index + 1, page.type ),
                    data: page.data
                }
            });

            let output = this._chapterOutputPath( chapter );
            if( Engine.Settings.chapterFormat.value === ChapterFormat.img ) {
                this._createDirectoryChain( output );
                this._saveChapterPagesFolder( output, pageData, callback );
            }
            if( Engine.Settings.chapterFormat.value === ChapterFormat.cbz ) {
                this._createDirectoryChain( this.path.dirname( output ) );
                this._saveChapterPagesCBZ( output, pageData, callback );
            }
            if( Engine.Settings.chapterFormat.value === ChapterFormat.pdf ) {
                this._createDirectoryChain( this.path.dirname( output ) );
                this._saveChapterPagesPDF( output, pageData, callback );
            }
            if( Engine.Settings.chapterFormat.value === ChapterFormat.epub ) {
                this._createDirectoryChain( this.path.dirname( output ) );
                this._saveChapterPagesEPUB( output, pageData, callback );
            }
        }

        /**
         * Create and save pages to the given e-book file.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesEPUB( ebook, pageData, callback ) {
            let zip = new this.jszip();
            zip.file( 'mimetype', EbookGenerator.createMimetype() );
            zip.folder( 'META-INF' ).file( 'container.xml', EbookGenerator.createContainerXML() );
            let oebps = zip.folder('OEBPS');
            oebps.folder( 'css' ).file( 'style.css', EbookGenerator.createStyleCSS() );
            let img = oebps.folder( 'img' );
            let xhtml = oebps.folder( 'xhtml' );
            let params = [];
            pageData.forEach( ( page, index ) => {
                img.file( page.name, page.data );
                xhtml.file( index + '.xhtml', EbookGenerator.createPageXHTML( page.name ) );
                params.push({
                    img: page.name,
                    xhtml: index + '.xhtml',
                    mime: this._pageFileMime( page.name )
                });
            });
            let uid = btoa( encodeURIComponent( ebook ) ).replace(/[^a-zA-Z]/g, '');
            let title = `${this.path.basename( this.path.dirname( ebook ) )} ${this.path.sep} ${this.path.basename( ebook, ChapterFormat.epub )}`;
            oebps.file( 'content.opf', EbookGenerator.createContentOPF( uid, title, params ) );
            oebps.file( 'toc.ncx', EbookGenerator.createTocNCX( uid, '', params ) );
            zip.generateAsync( { compression: 'STORE', type: 'uint8array' } ).then( ( data ) => {
                this.fs.writeFile( ebook, data, function( error ) {
                    callback( error );
                });
            });
        }

        /**
         * Create and save pages to the given portable document file.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesPDF( pdf, pageData, callback ) {
            let doc = new jspdf()
            doc.deletePage(1);
            this._addImageToPDF( doc, pageData, ( error ) => {
                try {
                    if( error ) {
                        throw error;
                    }
                    let data = doc.output( 'arraybuffer' /* 'blob' */ );
                    data = Buffer.from/*new Uint8Array*/( data );
                    this.fs.writeFile( pdf, data, ( error ) => {
                        callback( error );
                    } );
                } catch( e ) {
                    console.error( e );
                    callback( e );
                }
            } );
        }

        /**
         * Helper function to add images to a PDF document (recursive)
         */
        _addImageToPDF( pdfDocument, pageData, callback, pageIndex ) {
            try {
                if( pageIndex === undefined || pageIndex === null ) {
                    pageIndex = 0;
                }
                if( pageIndex >= pageData.length ) {
                    // operation complete
                    callback( null );
                    return;
                }
                if( !pdfDocument ) {
                    throw new Error( 'Source document is not a valid PDF!' );
                }
                let page = pageData[pageIndex];
                createImageBitmap( new Blob( [page.data], { type: this._pageFileMime( page.name ) } ) )
                .then( ( bitmap ) => {
                    try {
                        let data = page.data;
                        let pdfImgType = this._pdfImageType( page.name );
                        if( !pdfImgType ) {
                            pdfImgType = 'JPEG';
                            let canvas = document.createElement( 'canvas' );
                            canvas.width = bitmap.width;
                            canvas.height = bitmap.height;
                            let ctx = canvas.getContext( '2d' );
                            ctx.drawImage( bitmap, 0, 0 );
                            data = canvas.toDataURL( 'image/jpeg', 0.90 );
                        }
                        pdfDocument.addPage ( bitmap.width, bitmap.height );
                        // use page.name as image alias, to prevent imge repeat bug: https://github.com/MrRio/jsPDF/issues/998
                        pdfDocument.addImage( data, pdfImgType, 0, 0, bitmap.width, bitmap.height, page.name );
                        // process next image
                        this._addImageToPDF( pdfDocument, pageData, callback, pageIndex+1 );
                    } catch( e ) {
                        callback( e );
                    }
                } )
                .catch( ( e ) => {
                    callback( e );
                } );
            } catch( e ) {
                callback( e );
            }
        }

        /**
         * Create and save pages to the given archive file.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesCBZ( archive, pageData, callback ) {
            let zip = new this.jszip();
            pageData.forEach( ( page ) => {
                zip.file( page.name, page.data );
            });
            zip.generateAsync( { compression: 'STORE', type: 'uint8array' } ).then( ( data ) => {
                this.fs.writeFile( archive, data, function( error ) {
                    callback( error );
                });
            });
        }

        /**
         * Save pages to the given directory.
         * Callback will be executed after completion and provided with an array of errors (or an empty array when no errors occured).
         */
        _saveChapterPagesFolder( directory, pageData, callback ) {
            let error = null;
            let promise = new Promise( () => {
                callback( error );
            });
            pageData.forEach( ( page ) => {
                let key = promise.defer();
                this.fs.writeFile( this.path.join( directory, page.name ), page.data, function( writingError ) {
                    if( writingError ) {
                        if( error ) {
                            error = new Error( error.message + '\n' + writingError.message);
                        } else {
                            error = writingError;
                        }
                    }
                    promise.resolve( key );
                });
            });
        }

        /**
         * Store a file directly in the chapter directory
         */
        saveChapterFileM3U8( chapter, content, callback ) {
            let file = this._mangaOutputPath( chapter.manga );
            file = this.path.join( file, this.sanatizePath( chapter.title + EpisodeFormat.m3u8 ) );
            this._createDirectoryChain( file );
            file = this.path.join( file, this.sanatizePath( content.name ) );
            this.fs.writeFile( file, content.data, function( error ) {
                callback( error );
            });
        }

        /**
         * Multiplex chapter playlist/streams using the given ffmpeg command (without output format & file!).
         * The chapter directory is the working directory, and will be deleted after muxing.
         * The output file will be stored directly in the manga directory.
         */
        muxPlaylistM3U8( chapter, ffmpeg, callback ) {
            let directory = this._mangaOutputPath( chapter.manga );
            this._createDirectoryChain( directory );
            let file = this.path.join( directory, this.sanatizePath( chapter.title + EpisodeFormat.mkv ) );
            directory = this.path.join( directory, this.sanatizePath( chapter.title + EpisodeFormat.m3u8 ) );
            ffmpeg += ' -f matroska -y "' + file + '"';
            this.exec( ffmpeg, { cwd: directory, windowsHide: true }, callback );
        }

        /**
         * Helper function to generate the path where the connector mangas are stored.
         */
        _connectorOutputPath( connector ) {
            let output = Engine.Settings.baseDirectory.value;
            if( Engine.Settings.useSubdirectory.value ) {
                output = this.path.join( output, this.sanatizePath( connector.label ) );
            }
            return output;
        }

        /**
         * Helper function to generate the path where the manga chapters are stored.
         */
        _mangaOutputPath( manga ) {
            let output = this._connectorOutputPath( manga.connector );
            output = this.path.join( output, this.sanatizePath( manga.title ) );
            return output;
        }

        /**
         * Helper function to generate the path where the chapter pages are stored.
         */
        _chapterOutputPath( chapter ) {
            let output = this._mangaOutputPath( chapter.manga );
            output = this.path.join( output, this.sanatizePath( chapter.title ) );
            if( chapter.status === DownloadStatus.offline ) {
                return output;
            }
            // only valid for loading anime episodes, ignored when save pages
            if( this.fs.existsSync( output + EpisodeFormat.m3u8 ) ) {
                return output + EpisodeFormat.m3u8;
            }
            // only valid for loading anime episodes, ignored when save pages
            if( this.fs.existsSync( output + EpisodeFormat.mkv ) ) {
                return output + EpisodeFormat.mkv;
            }
            // used when loading and saving manga chapters
            if( Engine.Settings.chapterFormat.value !== ChapterFormat.img ) {
                output += Engine.Settings.chapterFormat.value;
            }
            return output;
        }

        /**
         * Helper function to recursively create all non-existing folders of the given path.
         */
        _createDirectoryChain( path ) {
            if( this.fs.existsSync( path ) || path === this.path.parse( path ).root ) {
                return;
            }
            this._createDirectoryChain( this.path.dirname( path ) );
            this.fs.mkdirSync( path, '0755', true );
        }

        /**
         * Create a path without forbidden characters.
         * Based on HakuNeko legacy for backward compatibility to detect existing mangas/chapters.
         * LINUX: wxT("/\r\n\t");
         * WINDOWS: wxT("\\/:*?\"<>|\r\n\t");
         */
        sanatizePath ( path ) {
            if( this.platform.indexOf( 'win' ) === 0 ) {
                // TODO: max. 260 characters per path
                path = path.replace( /[\\\/\:\*\?\"\<\>\|\r\n\t]/g, '' );
                return path.replace( /\.+$/g, '' ).trim(); // remove trailing dots and whitespaces
            }
            if( this.platform.indexOf( 'linux' ) === 0 ) {
                return path.replace( /[\/\r\n\t]/g, '' );
            }
            if( this.platform.indexOf( 'darwin' ) === 0 ) {
                // TODO: max. 32 chars per part
                return path.replace( /[\/\:\r\n\t]/g, '' );
            }
            return path;
        }

        /**
         * Helper function to generate an entry name for a page (picture) depending on the given number and mime type
         */
        _pageFileName( number, mimeType ) {
            let fileName = ( '00' + number ).slice( -3 );
            if( mimeType.indexOf( 'image/webp' ) > -1 ) {
                return fileName + '.webp';
            }
            if( mimeType.indexOf( 'image/jpeg' ) > -1 ) {
                return fileName + '.jpg';
            }
            if( mimeType.indexOf( 'image/png' ) > -1 ) {
                return fileName + '.png';
            }
            if( mimeType.indexOf( 'image/gif' ) > -1 ) {
                return fileName + '.gif';
            }
            if( mimeType.indexOf( 'image/bmp' ) > -1 ) {
                return fileName + '.bmp';
            }
            if( mimeType.indexOf( 'image/' ) > -1 ) {
                return fileName + '.img';
            }
            return fileName + '.bin';
        }

        /**
         * Helper function to get the mime type depending on the file extension of the given file name.
         */
        _pageFileMime( file ) {
            let extension = this.path.extname( file );
            if( extension === '.webp' ) {
                return 'image/webp';
            }
            if( extension === '.jpeg' ) {
                return 'image/jpeg';
            }
            if( extension === '.jpg' ) {
                return 'image/jpeg';
            }
            if( extension === '.png' ) {
                return 'image/png';
            }
            if( extension === '.gif' ) {
                return 'image/gif';
            }
            if( extension === '.bmp' ) {
                return 'image/bmp';
            }
            if( extension === '.img' ) {
                return 'image/';
            }
            return 'application/octet-stream';
        }

        /**
         * Helper function to get the image type for jsPDF of the given file name.
         */
        _pdfImageType( file ) {
            let extension = this.path.extname( file );
            if( extension === '.jpeg' ) {
                return 'JPEG';
            }
            if( extension === '.jpg' ) {
                return 'JPEG';
            }
            if( extension === '.png' ) {
                return 'PNG';
            }
            return undefined;
        }
    }

</script>