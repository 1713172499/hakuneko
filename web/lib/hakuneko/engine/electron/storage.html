<link rel="import" href="../base/storage.html">

<script>

    /**
     *
     */
    class StorageElectron extends StorageBase {

        /**
         *
         */
        constructor() {
            super();
            let electron = require( 'electron' );
            this.dialog = electron.remote.dialog;
            this.fs = electron.remote.require( 'fs' );
            this.path = electron.remote.require( 'path' );
            this.archiver = electron.remote.require( 'archiver' );
            this.admzip = electron.remote.require( 'adm-zip' );
            this.platform = require( 'electron' ).remote.process.platform;
        }

        /**
         * https://github.com/electron/electron/blob/master/docs/api/dialog.md
         */
        folderBrowser( rootPath ) {
            let directory = this.dialog.showOpenDialog( {
                title: 'Download Directory for Mangas',
                //message: 'MESSAGE',
                defaultPath: rootPath,
                properties: ['openDirectory']
            });
            return ( directory && directory.length > 0 ? directory[0] : rootPath );
        }

        /**
         * 
         */
        getMangaStatus( manga, callback ) {
            // wrap in timeout to prevent from blocking
            setTimeout( () => {
                this.fs.access( this._mangaOutputPath( manga ), /*this.fs.constants.F_OK,*/ ( error ) => {
                    if( error ) {
                        callback( DownloadStatus.available );
                    } else {
                        console.log( manga.title );
                        callback( DownloadStatus.completed );
                    }
                });
            }, 0);
        }

        /**
         * 
         */
        getChapterStatus( chapter ) {
            let path = this._chapterOutputPath( chapter );
            if( this.fs.existsSync( path ) || this.fs.existsSync( path + '.cbz' ) ) {
                return DownloadStatus.completed;
            }
            return DownloadStatus.available;
        }

        /**
         * 
         */
        loadChapterPages( chapter, callback ) {
            let path = this._chapterOutputPath( chapter );
            // try loading from directory
            this.fs.access( path, ( error ) => {
                if( !error ) {
                    this._loadChapterPagesFolder( path, callback );
                } else {
                    // try loading from CBZ archive
                    this.fs.access( path + '.cbz', ( error ) => {
                        if( !error ) {
                            this._loadChapterPagesCBZ( path + '.cbz', callback );
                        }
                    });
                }
            });
        }

        /**
         * 
         */
        _loadChapterPagesCBZ( archive, callback ) {
            setTimeout( () => {
                let zip = new this.admzip( archive );
                let pages = zip.getEntries().map( ( entry ) => {
                    // TODO: entry.getData() is very slow
                    return 'data:' + this._pageFileMime( entry.entryName ) + ';base64,' + entry.getData().toString( 'base64' );
                });
                callback( pages );
            }, 0 );
        }

        /**
         * 
         */
        _loadChapterPagesFolder( directory, callback ) {

            this.fs.readdir( directory, ( error, files ) => {
                let pages = files.map( ( file ) => {
                    file = this.path.join( directory, file );
                    return 'data:' + this._pageFileMime( file ) + ';base64,' + this.fs.readFileSync( file ).toString( 'base64' );
                });
                callback( pages );
                /*
                files.forEach( ( file ) => {
                    let file = this.path.join( directory, file );
                    setTimeout( () => {
                        console.log( file );
                    }, Math.random()*250 );
                });
                setTimeout( () => {
                    console.log( files );
                    callback( files );
                }, 300 );
                */
            });
        }

        /**
         * Save the pages of the given chapter.
         * The given content is a list of raw data for each corresponding page in the chapter.
         * The storage decides depending on the engine and available settings where the pages will be stored!
         */
        saveChapterPages( chapter, content, callback ) {
            let pageData = content.map( ( page, index ) => {
                return {
                    name: this._pageFileName( index + 1, page.type ),
                    data: page.data
                }
            });

            let output = this._chapterOutputPath( chapter );

            if( Engine.Settings.compressChapters.value ) {
                output += '.cbz';
                this._createDirectoryChain( this.path.dirname( output ) );
                this._saveChapterPagesCBZ( output, pageData, callback );
            } else {
                this._createDirectoryChain( output );
                this._saveChapterPagesFolder( output, pageData, callback );
            }
        }

        /**
         * Create and save pages to the given archive file.
         */
        _saveChapterPagesCBZ( archive, pageData, callback ) {
            let zip = this.archiver( 'zip', {
                zlib: {
                    level: 0
                }
            });
            zip.pipe( this.fs.createWriteStream( archive ) );
            pageData.forEach( ( page ) => {
                zip.append( page.data, { name: page.name } );
            });
            zip.finalize();
            callback();

            /*
	        var zip = new this.zipper();
            pageData.forEach( ( page ) => {
                zip.addFile( page.name, page.data );
            });
            zip.writeZip( archive );
            callback();
            */
        }

        /**
         * Save pages to the given directory.
         */
        _saveChapterPagesFolder( directory, pageData, callback ) {
            let promise = new Promise( callback );
            pageData.forEach( ( page ) => {
                let key = promise.defer();
                this.fs.writeFile( this.path.join( directory, page.name ), page.data, function( error ) {
                    promise.resolve( key );
                });
            });
        }

        /**
         * Helper function to generate the path where the chapter pages are stored.
         */
        _chapterOutputPath( chapter ) {
            let output = Engine.Settings.baseDirectory.value;
            if( Engine.Settings.useSubdirectory.value ) {
                output = this.path.join( output, this._sanatizePath( chapter.manga.connector.label ) );
            }
            output = this.path.join( output, this._sanatizePath( chapter.manga.title ) );
            output = this.path.join( output, this._sanatizePath( chapter.title ) );
            return output;
        }

        /**
         * Helper function to generate the path where the manga chapters are stored.
         */
        _mangaOutputPath( manga ) {
            let output = Engine.Settings.baseDirectory.value;
            if( Engine.Settings.useSubdirectory.value ) {
                output = this.path.join( output, this._sanatizePath( manga.connector.label ) );
            }
            output = this.path.join( output, this._sanatizePath( manga.title ) );
            return output;
        }

        /**
         * Helper function to recursively create all non-existing folders of the iven path.
         */
        _createDirectoryChain( path ) {
            if( this.fs.existsSync( path ) || path === this.path.parse( path ).root ) {
                return;
            }
            this._createDirectoryChain( this.path.dirname( path ) );
            this.fs.mkdirSync( path, '0755', true );
        }

        /**
         * Create a path without forbidden characters.
         * Based on HakuNeko legacy for backward compatibility to detect existing mangas/chapters.
         * LINUX: wxT("/\r\n\t");
         * WINDOWS: wxT("\\/:*?\"<>|\r\n\t");
         */
        _sanatizePath ( path ) {
            if( this.platform.indexOf( 'win' ) === 0 ) {
                // TODO: max. 260 characters per path
                return path.replace( /[\\\/\:\*\?\"\<\>\|\r\n\t]/g, '' );
            }
            if( this.platform.indexOf( 'linux' ) === 0 ) {
                return path.replace( /[\/\r\n\t]/g, '' );
            }
            if( this.platform.indexOf( 'darwin' ) === 0 ) {
                // TODO: max. 32 chars per part
                return path.replace( /[\/\:\r\n\t]/g, '' );
            }
            return path;
        }

        /**
         * Helper function to generate an entry name for a page (picture) depending on the given number and mime type
         */
        _pageFileName( number, mimeType ) {
            let fileName = ( '00' + number ).slice( -3 );
            if( mimeType.indexOf( 'image/jpeg' ) > -1 ) {
                return fileName + '.jpg';
            }
            if( mimeType.indexOf( 'image/png' ) > -1 ) {
                return fileName + '.png';
            }
            if( mimeType.indexOf( 'image/gif' ) > -1 ) {
                return fileName + '.gif';
            }
            if( mimeType.indexOf( 'image/bmp' ) > -1 ) {
                return fileName + '.bmp';
            }
            if( mimeType.indexOf( 'image/' ) > -1 ) {
                return fileName + '.img';
            }
            return fileName + '.bin';
        }

        /**
         * Helper function to get the mime time depending on the file extension of the gicen file name.
         */
        _pageFileMime( file ) {
            let extension = this.path.extname( file );
            if( extension === '.jpg' ) {
                return 'image/jpeg';
            }
            if( extension === '.png' ) {
                return 'image/png';
            }
            if( extension === '.gif' ) {
                return 'image/gif';
            }
            if( extension === '.bmp' ) {
                return 'image/bmp';
            }
            if( extension === '.img' ) {
                return 'image/';
            }
            return 'application/octet-stream';
        }
    }

</script>