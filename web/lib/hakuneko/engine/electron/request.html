<link rel="import" href="../base/request.html">

<script>

    /**
     *
     */
    class RequestElectron extends RequestBase {

        /**
         *
         */
        constructor() {
            super();
            this.electronRemote = require( 'electron' ).remote;
            this.protocol = this.electronRemote.require( 'electron' ).protocol;
            let req = this.electronRemote.require( 'request' );
            this.request = req.defaults( { jar: req.jar() } ); // cookies should be enabled
            this.agent = new this.electronRemote.require( 'http' ).Agent();
            this.crypto = this.electronRemote.require( 'crypto' );
            //this.browser = this.electronRemote.BrowserWindow;
            this.reconnectDelay = 250;
            this.reconnectErrors = [
                'ETIMEDOUT',
                'ESOCKETTIMEDOUT',
                'ECONNRESET',
                'ECONNREFUSED',
                //'EHOSTUNREACH',
                //'ENOTFOUND',
                //'EAI_AGAIN',
            ];
            this.ipChain = this._randIP( 3 ).join( ',' );
            this.protocolTable = [];
            /*
            let browserOptions = {
                width: 1280,
                height: 720,
                show: false,
                frame: false,
                webPreferences: {
                    nodeIntegration: true,
                    webSecurity: false,
                    //sandbox: true
                }
            };
            this.browserWindows = [];
            for( let i=0; i<5; i++ ) {
                let browser = {
                    // see: https://github.com/electron/electron/blob/master/docs/api/browser-window.md
                    window: new this.browser( browserOptions ),
                    busy: false
                };
                // block pupups
                browser.window.webContents.on( 'new-window', ( evt ) => {
                    evt.preventDefault();
                } );
                // create new window if the current one is destroyed for some reason ...
                // =>problems when closing hakuneko main application, remove close event from all existing windows and then close them
                
                //let listener = () => {
                //    console.warn( 'WINDOW DESTROYED' );
                //    browser.window = new this.browser( browserOptions );
                //    browser.window.once( 'closed', listener );
                //    browser.busy = false;
                //};
                //browser.window.once( 'closed', listener );
                
                this.browserWindows.push( browser );
            }
            */
            //
            document.addEventListener( EventListener.onSettingsChanged, this.onSettingsChanged.bind( this ) );
        }

        /**
         *
         */
        onSettingsChanged( e ) {
            this.agent.maxSockets = e.detail.socketConnections.value;
            // set google data saver for electron browser window requests (does not apply to NPM request module).
            let proxy = {};
            if( e.detail.useGoogleDataSaver.value ) {
                proxy['proxyRules'] = 'http://proxy.googlezip.net:80'; // 'socks5://127.0.0.1:8080';
            }
            this.electronRemote.session.defaultSession.setProxy( proxy, () => {
                //console.log( 'SET PROXY:', proxy );
            });
        }

        /**
         *
         */
        registerProtocol( scheme, callback ) {
            this.protocolTable[scheme + ':'] = callback;
            // register callback for electron process (when callback becomes unavailable by e.g. by reloading page, the previous registered handler must be removed)
            this.protocol.isProtocolHandled( scheme, ( error ) => {
                if( error ) {
                    this.protocol.unregisterProtocol( scheme, ( e ) => {
                        this.protocol.registerBufferProtocol( scheme, callback );
                    } );
                } else {
                    this.protocol.registerBufferProtocol( scheme, callback );
                }
            } );
        }

        /**
         * Since the request module does not support custom protocol handler we need to track and take care of them ourselves
         */
        _handleProtocol( options, callback ) {
            let protocol = ( new URL( options.url ) ).protocol;
            if( !this.protocolTable[protocol] ) {
                return false;
            }
            let request = {
                url: options.url, //url String
                referrer: options.url, //referrer String
                //method: '', //method String
                //uploadData: [], //uploadData UploadData[]
            }
            this.protocolTable[protocol]( request, ( data ) => {
                let error = null;
                let response = {
                    statusCode: 200,
                    headers: {
                        'Content-Type': data.mimeType
                    }
                };
                callback( error, response, data.data );
            });
            return true;
        }

        /**
         * Electron specific implementation of the fetch method to make HTTP requests.
         */
        fetch( options, callback, retries ) {
            options = this._prepareHeaders( options );
            if( this._handleProtocol( options, callback ) ) {
                return;
            }
            retries = ( retries != undefined ? retries : 3 );
            if( retries < 0 ) {
                callback( new Error( 'The url "' + ( options.url ? options.url : options ) + '" could not be reached' ), undefined, undefined );
                return;
            }
            this.request( options, ( error, response, content ) => {
                //
                if( error && this.reconnectErrors.indexOf( error.code ) > -1 ) {
                    setTimeout( () => {
                        //console.warn( 'RETRY:', error.code, options );
                        this.fetch( options, callback, retries-1 );
                    }, this.reconnectDelay  );
                } else {
                    callback( error, response, content );
                }
            } );
        }

        /**
         * Generate content of 'Chrome-Proxy' header field for use with google data saver
         */
        _getDataSaverHeader() {
            let key = 'ac4500dd3b7579186c1b0620614fdb1f7d61f944';
            let ts = Math.floor( Date.now() / 1000 );
            let hash = this.crypto.createHash( 'md5' ).update( ts + key + ts ).digest( 'hex' );
            let rd = Math.floor( 9999 * Math.random() );
            return 'ps=' + [ ts, rd, rd, rd ].join( '-' ) + ', sid=' + hash + ', b=3239, p=132, c=linux';
        }

        /**
         * Generate random IPs ( 1 ~ amount )
         */
        _randIP( amount ) {
            amount = amount || 1;
            let result = [];
            let rd = ( min, max ) => {
                return Math.floor( Math.random() * ( max - min + 1 ) ) + min;
            };
            let count = rd( 1, amount );
            for(let i=0; i<count; i++) {
                let ip = [ rd( 32, 224 ), rd( 1, 255 ), rd( 1, 255 ), rd( 1, 255 ) ];
                result.push( ip.join( '.' ) );
            }
            return result;
        }

        /**
         *
         */
        /*
        fetchUI( options, script, callback ) {
            //
            //console.log( 'BUSY:', this.browserWindows.filter( ( b ) => { return b.busy; } ).length );
            let browsers = this.browserWindows.filter( ( b ) => {
                return !b.busy;
            } );
            if( browsers.length === 0 ) {
                // retry in 1~5 seconds
                setTimeout( () => {
                    this.fetchUI( options, script, callback );
                }, Math.floor( 4000 * Math.random() + 1000 )  );
                return;
            }
            let browser = browsers[0];
            browser.busy = true;
            let win = browser.window;

            options = this._prepareHeaders( options );
            
            browser.window.webContents.setUserAgent( ( options.headers['User-Agent'] ? options.headers['User-Agent'] : this.userAgent ) );

            browser.window.webContents.on( 'crashed', ( e ) => {
                console.warn( 'crashed', browser.window.getURL(), e );
            } );
            browser.window.webContents.on( 'did-fail-load', ( e, ec, ed ) => {
                console.warn( 'did-fail-load', browser.window.getURL(), e, ec, ed );
            } );

            browser.window.webContents.on( 'dom-ready', ( evt ) => {
console.warn( 'dom-ready BUSY ENGINES:', this.browserWindows.filter( ( b ) => { return b.busy; } ).length );
                let timeout = setTimeout( () => {
                    console.log( 'TIMEOUT: executeJavaScript', browser.window.getURL(), browser.busy );
                    browser.window.webContents.removeAllListeners( 'dom-ready' );
                    callback( new Error( 'TIMEOUT: executeJavaScript' ), undefined );
                    browser.busy = false;
                }, 25000 );
                // do not process when this is a cloudflare challenge and wait for next call of dom-ready (after redirect)
                browser.window.webContents.executeJavaScript( `document.querySelector( 'input#jschl-answer' ) === null;` )
                .then( ( resultOuter ) => {
                    console.log( 'THEN [OUTER] executeJavaScript', resultOuter );
                    if( resultOuter ) {
                        browser.window.webContents.executeJavaScript( script )
                        .then( ( resultInner ) => {
                            clearTimeout( timeout );
                            console.log( 'THEN [INNER] executeJavaScript', ( resultInner ? resultInner.length : resultInner ) );
                            browser.window.webContents.removeAllListeners( 'dom-ready' );
                            browser.busy = false;
                            callback( null, resultInner );
                        } )
                        .catch( ( error ) => {
                            clearTimeout( timeout );
                            console.log( 'CATCH [INNER] executeJavaScript', error );
                            browser.window.webContents.removeAllListeners( 'dom-ready' );
                            browser.busy = false;
                            callback( error, undefined );
                        } );
                    } else {
                        console.log( 'CLOUDFLARE...' );
                        browser.window.show();
                    }
                } )
                .catch( ( error ) => {
                    clearTimeout( timeout );
                    console.log( 'CATCH [OUTER] executeJavaScript', error );
                    browser.window.webContents.removeAllListeners( 'dom-ready' );
                    browser.busy = false;
                    callback( error, undefined );
                } );
            } );
            // see: https://electronjs.org/docs/api/webview-tag#webviewloadurlurl-options
            let opts = {};
            browser.window.loadURL( options.url, opts );
        }
        */

        /**
         * Modify the request options to use any configured proxy server (e.g. Google Data Saver).
         * Set options & headers for NPM request module (does not apply to electron browser window).
         */
        _prepareHeaders( options ) {
            if( typeof options === 'string' ) {
                options = {
                    url: options
                };
            }
            let uri = new URL( options.url );
            options['headers'] = ( options['headers'] ? options['headers'] : {} );
            // it cannot hurt to pretend the request already passed through some other proxy servers ...
            options['headers']['X-Forwarded-For'] = this.ipChain;
            // use google data saver proxy server
            if( Engine.Settings.useGoogleDataSaver.value ) {
                //
                options['proxy'] = 'http://proxy.googlezip.net:80';
                options['headers']['Chrome-Proxy'] = this._getDataSaverHeader();
                options['gzip'] = true;
            }
            // connector specific headers ...
            if( uri.hostname.indexOf( 'mangapicgallery' ) > -1 ) {
                uri.hostname = 'www.mnggo.net';
                options['headers']['Referer'] = uri.href;
            }
            return options;
        }

        /**
         * Provide headers for the electron main process that shall be modified before every BrowserWindow request is made.
         * DO NOT RENAME THIS METHOD!
         */
        getRequestHeaders( details ) {
            details = JSON.parse( details );
            let uri = new URL( details.url );
            // details.url
            details.requestHeaders['X-Forwarded-For'] = this.ipChain;
            if( Engine.Settings.useGoogleDataSaver.value ) {
                details.requestHeaders['Chrome-Proxy'] = this._getDataSaverHeader();
            }
            // some manga connectors (e.g. DynastyScans) require a referer of the same origin for embeded images (ticket #2, commit [758df9])
            // => overwrite the referer for each request directly made through the electron browser
            // BUT: some other connectors like mangago require to keep the original referer
            //details.requestHeaders['Referer'] = details.url;
            if( uri.hostname.indexOf( 'mangapicgallery' ) > -1 ) {
                uri.hostname = 'www.mnggo.net';
                details.requestHeaders['Referer'] = uri.href;
            }

            return details;
        }
    }

</script>