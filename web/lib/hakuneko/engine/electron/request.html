<link rel="import" href="../base/request.html">

<script>

    /**
     *
     */
    class RequestElectron extends RequestBase {

        /**
         *
         */
        constructor() {
            super();
            let electron = require( 'electron' );
            this.webframe = electron.webFrame;
            this.electronRemote = electron.remote;
            this.protocol = this.electronRemote.require( 'electron' ).protocol;
            this.crypto = this.electronRemote.require( 'crypto' );
            this.browser = this.electronRemote.BrowserWindow;
            this.ipChain = this._randIP( 3 );
            this.protocolTable = [];

            //
            document.addEventListener( EventListener.onSettingsChanged, this.onSettingsChanged.bind( this ) );
        }

        /**
         *
         */
        onSettingsChanged( event ) {
            // set google data saver for electron browser window requests
            let proxy = {};
            if( event.detail.useGoogleDataSaver.value ) {
                proxy['proxyRules'] = 'http=http://proxy.googlezip.net:80';
                //proxy['proxyBypassRules'] = [ 'https://*' ];
            }
            this.electronRemote.session.defaultSession.setProxy( proxy, () => {
                //console.log( 'SET PROXY:', proxy );
            } );
        }

        /**
         *
         */
        registerProtocol( scheme, callback ) {
            // register as privileged to allow this protocol be used with fetch API (otherwise only http[s] is allowed)
            this.webframe.registerURLSchemeAsPrivileged( scheme );
            // register callback for electron process (when callback becomes unavailable by e.g. by reloading page,
            // the previous registered handler must be removed)
            this.protocol.isProtocolHandled( scheme, error => {
                if( error ) {
                    this.protocol.unregisterProtocol( scheme, event => {
                        this.protocol.registerBufferProtocol( scheme, callback );
                    } );
                } else {
                    this.protocol.registerBufferProtocol( scheme, callback );
                }
            } );
        }

        /**
         *
         */
        _cfCheckScript() {
            // ensure variables in this script does not appear in the page or other injected script
            let uVar = [
                '_c13367', // 'code',
                '_d8fd50', // 'message',
                '_cb5e10', // 'error',
                '_e9a23c', // 'meta',
                '_d9904d', // 'cf',
                '_b4a884', // 'result',
            ];
            return `
                let ${uVar[0]} = document.querySelector( '.cf-error-code' );
                ${uVar[0]} = ( ${uVar[0]} ? ${uVar[0]}.innerText : null );
                let ${uVar[1]} = document.querySelector( 'h2[data-translate]' );
                ${uVar[1]} = ( ${uVar[1]} && ${uVar[1]}.nextElementSibling ? ${uVar[1]}.nextElementSibling.innerText : null );
                let ${uVar[2]} = ( ${uVar[0]} ? 'CF Error ' + ${uVar[0]} + ' => ' + ${uVar[1]} : null );

                let ${uVar[3]} = document.querySelector( 'meta[http-equiv="refresh"][content*="="]' );
                let ${uVar[4]} = document.querySelector( 'form#challenge-form' );

                let ${uVar[5]} = {
                    error: ${uVar[0]},
                    redirect: ( ${uVar[3]} || ${uVar[4]} )
                };
                ${uVar[5]};
            `;
        }

        /**
         *
         */
        fetchUI( url, requestOptions, injectionScript ) {
            return new Promise( ( resolve, reject ) => {
                let win = new this.browser( {
                    show: false,
                    webPreferences: {
                        nodeIntegration: false,
                        webSecurity: true
                    }
                } );

                let preventCallback = false;

                let abortAction = setTimeout( () => {
                    this._fetchUICleanup( win, abortAction );
                    if( !preventCallback ) {
                        reject( new Error( 'Failed to load ' + url ) );
                    }
                }, 15000 );
                
                win.webContents.session.webRequest.onBeforeRequest( { urls: ['http://*/mobi/js/chapter.js*'] }, ( details, callback ) => {
                    callback( { redirectURL: 'cache://hakuneko/js/chapter.js' } );
                } );

                win.webContents.on( 'did-finish-load', event => {
                    win.webContents.executeJavaScript( this._cfCheckScript(), result => {
                        if( !result.redirect ) {
                            if( result.error ) {
                                this._fetchUICleanup( win, abortAction );
                                reject( result.error );
                            } else {
                                preventCallback = true; // no other event shall resolve/reject this promise anymore
                                win.webContents.executeJavaScript( injectionScript, ( result ) => {
                                    this._fetchUICleanup( win, abortAction );
                                    resolve( result );
                                } );
                            }
                        }
                    } );
                } );

                win.webContents.on( 'did-fail-load', ( event, errCode, errMessage, uri, isMain ) => {
                    if( !preventCallback && errCode && errCode !== -3 && ( isMain || uri === url ) ) {
                        this._fetchUICleanup( win, abortAction );
                        reject( new Error( errMessage + ' ' + uri ) );
                    }
                } );

                let options = {
                    httpReferrer: requestOptions.headers.get( 'x-referer' ) || url,
                    userAgent: requestOptions.headers.get( 'x-user-agent' )/*,
                    // extraHeaders String (optional) - Extra headers separated by "\n"
                    // TODO: add all headers from request options ...
                    extraHeaders: 'X-Forwarded-For: ' + requestOptions.headers.get( 'x-forwarded-for' )
                                  + '\nForwarded: ' + requestOptions.headers.get( 'forwarded' )
                                  + '\nCookie: PHPSESSID=' + Math.random() + ';'
                    */
                };
                win.loadURL( url, options );
            } );
        }

        /**
         * Close window and clear the given timeout function
         */
        _fetchUICleanup( browserWindow, timeout ) {
            if( timeout ) {
                clearTimeout( timeout );
            }
            timeout = null;
            if( browserWindow ) {
                browserWindow.close();
            }
            browserWindow = null;
        }

        /**
         * Generate content of 'Chrome-Proxy' header field for use with google data saver
         */
        _getDataSaverHeader() {
            let key = 'ac4500dd3b7579186c1b0620614fdb1f7d61f944';
            let ts = Math.floor( Date.now() / 1000 );
            let hash = this.crypto.createHash( 'md5' ).update( ts + key + ts ).digest( 'hex' );
            let rd = Math.floor( 9999 * Math.random() );
            return 'ps=' + [ ts, rd, rd, rd ].join( '-' ) + ', sid=' + hash + ', b=3239, p=132, c=linux';
        }

        /**
         * Generate random IPs ( 1 ~ amount )
         */
        _randIP( amount ) {
            amount = amount || 1;
            let result = [];
            let rd = ( min, max ) => {
                return Math.floor( Math.random() * ( max - min + 1 ) ) + min;
            };
            let count = amount; // rd( 1, amount );
            // us ip blocks: https://www.nirsoft.net/countryip/us.html
            //let usBlocks = [3,4,6,7,8,9,11,12,15,16,17,18,19,20,21,22,26,28,29,30,33,34,38,44,48,55,56,73,214,215];
            for(let i=0; i<count; i++) {
                let ip = [ rd( 1, 255 ), rd( 1, 255 ), rd( 1, 255 ), rd( 1, 255 ) ];
                result.push( ip.join( '.' ) );
            }
            return result;
        }

        /**
         * Provide headers for the electron main process that shall be modified before every BrowserWindow request is made.
         * DO NOT RENAME THIS METHOD!
         */
         onBeforeSendHeadersHandler( details ) {
            try {
                details = JSON.parse( Buffer.from( details, 'base64' ).toString( 'utf8' ) );
            } catch( error ) {
                console.log( error, details );
                return undefined;
            }
            console.log( 'Request.onBeforeSendHeadersHandler():', details );
            let uri = new URL( details.url );

            // Overwrite the User-Agent header
            if( details.requestHeaders['x-user-agent'] ) {
                details.requestHeaders['User-Agent'] = details.requestHeaders['x-user-agent'];
                delete details.requestHeaders['x-user-agent'];
            }

            // Overwrite the Referer header, but
            // NEVER overwrite the referer for cloudflare's DDoS protection to prevent infinite redirects!
            if( !uri.pathname.endsWith( 'chk_jschl' ) ) {
                // use referer provided by connector
                if( details.requestHeaders['x-referer'] ) {
                    details.requestHeaders['Referer'] = details.requestHeaders['x-referer'];
                    delete details.requestHeaders['x-referer'];
                } else {
                    // some manga connectors (e.g. DynastyScans) require a referer of the same origin for images (ticket #2, commit [758df9])
                    // => overwrite the referer for each request
                    details.requestHeaders['Referer'] = details.url;
                }
            }

            // Overwrite the Origin header
            if( details.requestHeaders['x-origin'] ) {
                details.requestHeaders['Origin'] = details.requestHeaders['x-origin'];
                delete details.requestHeaders['x-origin'];
            }

            // Append Cookie header
            if( details.requestHeaders['x-cookie'] ) {
                let cookiesORG = ( details.requestHeaders['Cookie'] || '' ).split( ';' ).map( c => c.trim() );
                let cookiesNEW = details.requestHeaders['x-cookie'].split( ';' ).map( c => c.trim() );
                details.requestHeaders['Cookie'] = cookiesORG.concat( cookiesNEW ).join( '; ' );
                delete details.requestHeaders['x-cookie'];
            }

            //console.log( '  => REFERER:', details.requestHeaders['Referer'] );
            // it cannot hurt to pretend the request already passed through some other proxy servers ...
            
            /*
            Disabled, because rejected by MangaDex
            if( details.requestHeaders['X-Forwarded-For'] === undefined ) {
                details.requestHeaders['X-Forwarded-For'] = this.ipChain.join( ',' );
            }
            if( details.requestHeaders['Forwarded'] === undefined ) {
                details.requestHeaders['Forwarded'] = this.ipChain.map( ip => 'for=' + ip ).join( ',' );
            }
            */
            if( uri.protocol === 'http:' && Engine.Settings.useGoogleDataSaver.value ) {
                details.requestHeaders['Chrome-Proxy'] = this._getDataSaverHeader();
            }

            return details;
        }
    }

</script>