<link rel="import" href="../base/request.html">

<script>

    /**
     *
     */
    class RequestElectron extends RequestBase {

        /**
         *
         */
        constructor() {
            super();
            let req = require( 'electron' ).remote.require( 'request' );
            this.request = req.defaults( { jar: req.jar() } ); // cookies should be enabled
            this.agent = new require( 'electron' ).remote.require( 'http' ).Agent();
            this.crypto = require( 'electron' ).remote.require( 'crypto' );
            this.browser = require( 'electron' ).remote.BrowserWindow;
            this.reconnectDelay = 250;
            this.reconnectErrors = [
                'ETIMEDOUT',
                'ESOCKETTIMEDOUT',
                'ECONNRESET',
                'ECONNREFUSED',
                //'EHOSTUNREACH',
                //'ENOTFOUND',
                //'EAI_AGAIN',
            ];
            document.addEventListener( EventListener.onSettingsChanged, this.onSettingsChanged.bind( this ) );
        }

        /**
         *
         */
        onSettingsChanged( e ) {
            this.agent.maxSockets = e.detail.socketConnections.value;
        }

        /**
         * DEPRECATED (2018-01-14): Use fetch() method instead
         * 
         * Electron specific implementation of the get method for the request engine.
         * Callback arguments:
         *   error => error that occurs in request module (or null if no error)
         *   content => the content of the requested url
         *   status => http status code of the request
         *   headers => response headers of the request
         */
        get( href, referer, agent, callback ) {
            let options = {
                method: 'GET',
                rejectUnauthorized: false,
                url: href,
                headers: {
                    'User-Agent': agent || this.userAgent,
                    'Referer': referer || href
                },
                gzip: true,
                //realEncoding: 'utf8',
                encoding: null, // keep content in binary presentation and do not convert
                pool: this.agent,
                timeout: 15000
            };
//console.log( '   GET', options.url, options.headers['Referer'], options.headers['User-Agent'] );
            this.request.get( options, ( error, response, content ) => { this._requestCallback( error, response, content, options, callback ); } );
        }

        /**
         * DEPRECATED (2018-01-14): Use fetch() method instead
         * 
         * Electron specific implementation of the post method for the request engine.
         * Callback arguments:
         *   error => error that occurs in request module (or null if no error)
         *   content => the content of the requested url
         *   status => http status code of the request
         *   headers => response headers of the request
         */
        post( href, form, referer, agent, callback ) {
            let options = {
                method: 'POST',
                rejectUnauthorized: false,
                url: href,
                headers: {
                    'User-Agent': agent || this.agent,
                    'Referer': referer || href
                },
                gzip: true,
                form: form,
                //realEncoding: 'utf8',
                encoding: null, // keep content in binary presentation and do not convert
                pool: this.agent,
                timeout: 15000
            };
            this.request.post( options, ( error, response, content ) => { this._requestCallback( error, response, content, options, callback ); } );
        }

        /**
         * Helper function relaying the processed results from the raw request to the callback.
         */
        _requestCallback ( error, response, content, options, callback, retries ) {
//console.log( 'REDIRECT', response.statusCode, options, response.request );
            retries = ( retries != undefined ? retries : 3 );
            if( retries < 0 ) {
                callback( new Error( 'The url "' + options.url + '" could not be reached' ), undefined, ( response ? response.statusCode : undefined ), ( response ? response.headers : undefined ) );
                return;
            }
            // no need to process cookies, they are handled automatically by JAR
            if( error || !response || !content ) {
                console.log( options.url, '[', retries, ']', error );
                if( error.code === 'ETIMEDOUT' || error.code === 'ESOCKETTIMEDOUT' || error.code === 'ECONNRESET' ) {
                    if( options.method.toUpperCase() === 'GET' ) {
                        this.request.get( options, ( error, response, content ) => { this._requestCallback( error, response, content, options, callback, retries - 1 ); } );
                    }
                    if( options.method.toUpperCase() === 'POST' ) {
                        this.request.post( options, ( error, response, content ) => { this._requestCallback( error, response, content, options, callback, retries - 1 ); } );
                    }
                    return;
                } else {
                    callback( error, undefined, ( response ? response.statusCode : undefined ), ( response ? response.headers : undefined ) );
                    return;
                }
            }
            let contentType = ( response.headers && response.headers['content-type'] ? response.headers['content-type'].toLowerCase() : '' );
            if( contentType.indexOf( 'text' ) > -1 || contentType.indexOf( 'json' ) > -1 || contentType.indexOf( 'javascript' ) > -1 ) {
                if( contentType.indexOf( 'charset=utf-8' ) > -1 ) {
                    content = content.toString( 'utf8' );
                } else {
                    content = content.toString();
                }
            }
            callback( null, content, response.statusCode, response.headers );
        };

        /**
         * Electron specific implementation of the fetch method to make HTTP requests.
         */
        fetch( options, callback, retries ) {
            this._proxify( options );
            retries = ( retries != undefined ? retries : 3 );
            if( retries < 0 ) {
                callback( new Error( 'The url "' + ( options.url ? options.url : options ) + '" could not be reached' ), undefined, undefined );
                return;
            }
            this.request( options, ( error, response, content ) => {
                //
                if( error && this.reconnectErrors.indexOf( error.code ) > -1 ) {
                    setTimeout( () => {
                        //console.warn( 'RETRY:', error.code, options );
                        this.fetch( options, callback, retries-1 );
                    }, this.reconnectDelay  );
                } else {
                    callback( error, response, content );
                }
            } );
        }

        /**
         * Modify the request options to use any configured proxy server (e.g. Google Data Saver)
         */
        _proxify( options ) {
            if( typeof options === 'string' ) {
                options = {
                    url: options
                };
            }
            options['headers'] = ( options['headers'] ? options['headers'] : {} );
            // it cannot hurt to pretend the request already passed through some other proxy servers ...
            options['headers']['X-Forwarded-For'] = this._randIP( 3 ).join( ',' );
            // use google data saver proxy server
            if( Engine.Settings.useGoogleDataSaver.value ) {
                let key = 'ac4500dd3b7579186c1b0620614fdb1f7d61f944';
                let ts = Math.floor(Date.now() / 1000);
                let hash = this.crypto.createHash( 'md5' ).update( ts + key + ts ).digest( 'hex' );
                let rd = Math.floor( 999 * Math.random() );
                //
                options['proxy'] = 'http://proxy.googlezip.net:80',
                options['headers']['Chrome-Proxy'] = 'ps=' + [ ts, rd, rd, rd ].join( '-' ) + ', sid=' + hash + ', b=3239, p=132, c=linux';
                options['gzip'] = true;
            }
        }

        /**
         * Generate random IPs ( 1 ~ amount )
         */
        _randIP( amount ) {
            amount = amount || 1;
            let result = [];
            let rd = ( min, max ) => {
                return Math.floor( Math.random() * ( max - min + 1 ) ) + min;
            };
            let count = rd( 1, amount );
            for(let i=0; i<count; i++) {
                let ip = [ rd( 32, 224 ), rd( 1, 255 ), rd( 1, 255 ), rd( 1, 255 ) ];
                result.push( ip.join( '.' ) );
            }
            return result;
        }

        /**
         *
         */
         fetchUI( uri, callback ) {
            let win = new this.browser( {
                width: 1280,
                height: 720,
                show: true
            });
            win.loadURL( uri );
            win.webContents.on( 'dom-ready', ( e ) => {
                console.log( win.getURL() );
                if( true ) {
                    setTimeout( () => {
                        win.close();
                        callback( 'RESULT' );
                    }, 7500 );
                }
            } );
        }
    }

</script>