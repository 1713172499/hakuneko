<script>

    /**
     * Base class for common BookmarkManager class implementation
     */
    class ChaptermarkManager {

        constructor() {
            this.chaptermarks = [];
        }

        /**
         *
         */
        exportChaptermarks() {
            return this.chaptermarks;
        }

        /**
         *
         */
        importChaptermarks( chaptermarks ) {
            if( !chaptermarks ) {
                return;
            }
            
            let marks = chaptermarks.filter( c => this._findIndex( c ) < 0 );
            this.chaptermarks = this.chaptermarks.concat( marks );
            this._syncChaptermarks( undefined );
        }

        /**
         *
         */
        _findIndex( chaptermark ) {
            return this.chaptermarks.findIndex( c => c.connectorID === chaptermark.connectorID && c.mangaID === chaptermark.mangaID );
        }

        /**
         * Try to save the current chaptermarks.
         * Will reset chaptermarks when saving fails.
         */
        _syncChaptermarks( callback ) {
            Engine.Storage.saveConfig( 'chaptermarks', this.chaptermarks )
            .then( () => {
                document.dispatchEvent( new CustomEvent( EventListener.onChaptermarksChanged, { detail: this.chaptermarks } ) );
                if( typeof( callback ) === typeof( Function ) ) {
                    callback( null );
                }
            } )
            .catch( error => {
                this.loadChaptermarks( callback );
             } );
        }

        /**
         *
         */
        loadChaptermarks( callback ) {
            Engine.Storage.loadConfig( 'chaptermarks' )
            .then( data => {
                try {
                    if( !data ) {
                        throw new Error( 'Invalid chaptermark list!' );
                    }
                    this.chaptermarks = data;
                    document.dispatchEvent( new CustomEvent( EventListener.onChaptermarksChanged, { detail: this.chaptermarks } ) );
                    if( typeof( callback ) === typeof( Function ) ) {
                        callback( null );
                    }
                } catch( e ) {
                    console.error( 'Failed to load chaptermarks:', e.message );
                    if( typeof( callback ) === typeof( Function ) ) {
                        callback( e );
                    }
                }
            } )
            .catch( error => {
                //if( typeof( callback ) === typeof( Function ) ) {
                //    callback( error );
                //}
                console.log( 'Migrating "chaptermarks" from indexedDB to persistant storage ...' );
                // [OBSOLETE] This call is only available for migration from indexedDB to persistant storage
                // >>>
                // can be removed in the next release > 0.3.1
                Engine.Storage.loadCollectionFromDB( 'chaptermarks', ( error, data ) => {
                    try {
                        if( error ) {
                            throw error;
                        }
                        if( !data ) {
                            throw new Error( 'Invalid chaptermark lst!' );
                        }
                        this.chaptermarks = data;
                        document.dispatchEvent( new CustomEvent( EventListener.onChaptermarksChanged, { detail: this.chaptermarks } ) );
                        if( typeof( callback ) === typeof( Function ) ) {
                            callback( null );
                        }
                        Engine.Storage.saveConfig( 'chaptermarks', data )
                        .catch( error => {
                            console.warn( 'Failed to copy "chaptermarks" from indexedDB into persistant storage', error );
                            alert( 'Failed to copy your chaptermarks to the new persistant storage.\nIt would be helpful if you report this problem along with the console output.\n\nhttps://sourceforge.net/p/hakuneko/discussion/support/' );
                        } );
                    } catch ( e ) {
                        console.error( 'Failed to load chaptermarks:', e.message );
                        if( typeof( callback ) === typeof( Function ) ) {
                            callback( e );
                        }
                    }
                } );
                // <<<
            } );
        }

        /**
         * Get the chapter mark for the given manga (or undefined if no chapter is marked for the manga)
         */
        getChaptermark( manga ) {
            if( manga ) {
                return this.chaptermarks.find( ( chaptermark ) => {
                    return ( chaptermark.mangaID === manga.id && chaptermark.connectorID === manga.connector.id ); 
                } );
            }
            return undefined;
        }

        /**
         * Mark the given chapter (replace any existing marked chapter for this connector/manga)
         */
        addChaptermark( chapter ) {
            if( !chapter || !chapter.manga || !chapter.manga.connector ) {
                return;
            }
            let chaptermark = {
                connectorID: chapter.manga.connector.id,
                mangaID: chapter.manga.id,
                chapterID: chapter.id
            };
            let index = this._findIndex( chaptermark );
            if( this._findIndex( chaptermark ) > -1 ) {
                this.chaptermarks[index] = chaptermark;
            } else { 
                this.chaptermarks.push( chaptermark );
            }
            this._syncChaptermarks();
        }

        /**
         *
         */
        deleteChaptermark( chapter ) {
            if( !chapter || !chapter.manga || !chapter.manga.connector ) {
                return;
            }
            let chaptermark = {
                connectorID: chapter.manga.connector.id,
                mangaID: chapter.manga.id,
                chapterID: chapter.id
            };
            let index = this._findIndex( chaptermark );
            if( index > -1 ) {
                this.chaptermarks.splice( index, 1 );
                this._syncChaptermarks();
            }
        }
    }
    ChaptermarkManager; // reference the class to prevent removal of the class through js-minify

</script>