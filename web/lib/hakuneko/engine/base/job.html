<link rel="import" href="enums.html">

<script>

    /**
     *
     */
    class DownloadJob {

        /**
         *
         */
        constructor( chapter ) {
            this.id = Symbol();
            this.chapter = chapter;
            this.labels = {
                connector: chapter.manga.connector.label,
                manga: chapter.manga.title,
                chapter: chapter.title
            };
            this.requestOptions = chapter.manga.connector.requestOptions || {};
            this.throttle = ( chapter.manga.connector.config['throttle'] ? chapter.manga.connector.config['throttle'].value : 50 );
            this.status = undefined;
            this.progress = 0;
            this.errors = [];
        }

        /**
         * 
         */
        isSame( job ) {
            // comparing chapter objects works, because chapters for each manga are cached
            return ( this.chapter === job.chapter);
            //return ( this.chapter.id === job.chapter.id && this.chapter.manga.id === job.chapter.manga.id && this.chapter.manga.connector.id === job.chapter.manga.connector.id );
        }

        /**
         * Apply a new status for the job and publish the corresponding event.
         */
        setStatus( status ) {
            if( status !== this.status ) {
                this.status = status;
                this.chapter.setStatus( status );
                this.chapter.manga.updateStatus();
                document.dispatchEvent( new CustomEvent( EventListener.onDownloadStatusUpdated, { detail: this } ) );
            }
        }

        /**
         * Apply a new status for the job and publish the corresponding event.
         */
        setProgress( progress ) {
            if( progress !== this.progress ) {
                this.progress = progress;
                document.dispatchEvent( new CustomEvent( EventListener.onDownloadStatusUpdated, { detail: this } ) );
            }
        }

        /**
         *
         */
        downloadPages( directory, callback ) {
            this.setStatus( DownloadStatus.downloading );
            this.chapter.getPages( ( error, data ) => {
                if( !error && data ) {
                    // manga pages
                    if( data.length ) {
                        this._downloadPages( data, directory, callback );
                        return;
                    }
                    // anime playlist
                    if( data.playlist ) {
                        this._downloadPlaylistHLS( data, directory, callback );
                        return;
                    }
                }

                if( error ) {
                    this.errors.push( error );
                } else {
                    this.errors.push( new Error( 'Page list is empty' ) );
                }
                this.setStatus( DownloadStatus.failed );
                this.setProgress( 100 );
                callback();
            } );
        }

        /**
         * Return a promise that will be resolved after the given amount of time in milliseconds
         */
        _wait( time ) {
            return new Promise( ( resolve, reject ) => {
                setTimeout( resolve, time );
            } );
        }

        /**
         *
         */
        _downloadPages( pages, directory, callback ) {
            // get data for all pages of chapter
            let promises = pages.map( ( page, index ) => {
                return this._wait( index * this.throttle )
                .then( () => {
                    return Engine.Request.cloudflare( page, this.requestOptions );
                } )
                .then( response => {
                    if( response.status !== 200 ) {
                        throw new Error( 'Page "' + page + '" returned status: ' + response.status + ' - ' + response.statusText );
                    }
                    return response.blob();
                } )
                .then( data => {
                    this.setProgress( this.progress + ( pages.length ? 100/pages.length : 0 ) );
                    return Promise.resolve( data );
                } );
            } );
            Promise.all( promises )
            .then( values => {
                return Engine.Storage.saveChapterPages( this.chapter, values );
            } )
            .then( () => {
                this.setProgress( 100 );
                this.setStatus( DownloadStatus.completed );
                callback();
            } )
            .catch( error => {
                // TODO: abort/block all other page downloads that are still running for this job ...
                // https://stackoverflow.com/questions/31424561/wait-until-all-es6-promises-complete-even-rejected-promises
                console.error( error, pages );
                this.setProgress( 100 );
                this.setStatus( DownloadStatus.failed );
                callback();
            } );
        }

        /**
         * 
         */
        _downloadPlaylistHLS( episode, directory, callback ) {
            let ffmpeg = {
                command: ['ffmpeg', '-allowed_extensions', 'ALL'],
                inputs: [],
                maps: ['-map', '0:v', '-map', '0:a'],
                metas: []
            };
            // download playlist
            fetch( episode.playlist, this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( 'Playlist "' + episode.playlist + '" returned status: ' + response.status + ' - ' + response.statusText );
                }
                return response.text();
            } )
            .then( playlist => {
                // parse links and adjust playlist
                let packets = playlist.match( /http[s]?:\/\/[^\s\"]+/g ).map( link => {
                    let file = this.chapter.id + '.' + ( new URL( link ) ).pathname.split( '/' ).pop();
                    // ffmpeg does not support backslashes => replace with slashes
                    playlist = playlist.replace( link, file.replace( /\\/g, '/' ) );
                    return {
                        source: link,
                        target: file
                    };
                } );
                ffmpeg.inputs.push( '-i', '"' + this.chapter.id + '.m3u8"' );
                return Engine.Storage.saveChapterFileM3U8( this.chapter, { name: this.chapter.id + '.m3u8', data: playlist } )
                .then( () => {
                    return Promise.resolve( packets );
                 } );
            } )
            // download all packets
            .then( packets => {
                let promises = packets.map( ( packet, index ) => {
                    return this._wait( index * this.throttle )
                    .then( () => {
                        return fetch( packet.source, this.requestOptions );
                    } )
                    .then( response => {
                        if( response.status !== 200 ) {
                            throw new Error( 'Packet "' + packet.link + '" returned status: ' + response.status + ' - ' + response.statusText );
                        }
                        return response.arrayBuffer();
                    } )
                    .then( data => {
                        return Engine.Storage.saveChapterFileM3U8( this.chapter, { name: packet.target, data: new Uint8Array( data ) } );
                    } )
                    .then( () => {
                        this.setProgress( this.progress + 100/packets.length );
                    } );
                } );
                return Promise.all( promises );
            } )
            // download all subtitles
            .then( () => {
                let promises = episode.subtitles.map( ( subtitle, index ) => {
                    let file = this.chapter.id + '.' + subtitle.locale + '.' + subtitle.format;
                    ffmpeg.inputs.push( '-i', '"' + file + '"' );
                    ffmpeg.maps.push( '-map', ( index + 1 ) + ':s' );
                    ffmpeg.metas.push( '-metadata:s:s:' + index, 'language=' + subtitle.locale );
                    // make english the default subtitle
                    if( subtitle.locale.toLowerCase() === 'en-us' ) {
                        ffmpeg.metas.push( '-disposition:s:' + index, 'default' );
                    }
                    return this._wait( index * 50 )
                    .then( () => {
                        return fetch( subtitle.url, this.requestOptions );
                    } )
                    .then( response => {
                        if( response.status !== 200 ) {
                            throw new Error( 'Subtitle "' + subtitle.url + '" returned status: ' + response.status + ' - ' + response.statusText );
                        }
                        return response.text();
                    } )
                    .then( data => {
                        return Engine.Storage.saveChapterFileM3U8( this.chapter, { name: file, data: data } );
                    } );
                } );
                return Promise.all( promises );
            } )
            // multiplex
            .then( () => {
                // compose ffmpeg command for multiplexing
                let args = ffmpeg.command;
                args = args.concat( ffmpeg.inputs );
                args = args.concat( ffmpeg.maps );
                args = args.concat( ffmpeg.metas );
                args = args.concat( [ '-c', 'copy' ] );
                // multiplex media
                return Engine.Storage.muxPlaylistM3U8( this.chapter, args.join( ' ' ) );
            } )
            // finalize
            .then( () => {
                this.setProgress( 100 );
                this.setStatus( DownloadStatus.completed );
                callback();
            } )
            // process error
            .catch( error => {
                // TODO: abort/block all other packet downloads that are still running for this job ...
                // https://stackoverflow.com/questions/31424561/wait-until-all-es6-promises-complete-even-rejected-promises
                console.error( error, episode );
                this.setProgress( 100 );
                this.setStatus( DownloadStatus.failed );
                callback();
            } );
        }
    }
    DownloadJob; // reference the class to prevent removal of the class through js-minify

</script>