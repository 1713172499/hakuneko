<link rel="import" href="enums.html">
<link rel="import" href="manga.html">
<link rel="import" href="useragent.html">

<script>

    /**
     * Base class for connector plugins
     */
    class Connector {

        /**
         *
         */
        constructor() {
            this.id = Symbol();
            this.label = '';
            // READONLY: lock state may used to prevent to many concurrent requests per second
            // do not set directly, use lock() and unlock()
            this.isLocked = false;
            //
            this.isUpdating = false;
            //
            this.mangaCache = undefined;
            //
            this.existingMangas = [];
        }

        /**
         * Update the manga list in the local storage.
         * Callback will be executed after completion and provided with a reference to the manga list (undefined on error).
         */
        updateMangas( callback ) {
            if( this.isUpdating ) {
                return;
            }
            this.isUpdating = true;
            this._getMangaList( ( error, mangas ) => {
                if( error || !mangas ) {
                    console.error( ( error ? error.message : 'Failed updating mangas!' ) );
                    this.isUpdating = false;
                    callback( error, undefined );
                    return;
                }
                mangas.sort( ( a, b ) => {
                    return ( a.title.toLowerCase() < b.title.toLowerCase() ? -1 : 1 );
                });
                // save manga list to local storage
                Engine.Storage.saveMangaList( this.id, mangas, ( error ) => {
                    // callback function may access update status, so set it before executing callback
                    this.isUpdating = false;
                    this.mangaCache = undefined;
                    if( error ) {
                        // update failed
                        console.error( error.message );
                        callback( error, undefined );
                    } else {
                        // de-serialize manga list from local storage
                        this.getMangas( callback );
                    }
                });
            });
        }

        /**
         * Get all mangas for the connector.
         * Callback will be executed after completion and provided with a reference to the manga list (undefined on error).
         */
        getMangas( callback ) {
            // find all manga titles (sanitized) that are found in the base directory for this connector
            Engine.Storage.getExistingMangaTitles( this, ( error, existingMangaTitles ) => {
                this.existingMangas = existingMangaTitles;
                // check if manga list is cached
                if( this.mangaCache ) {
                    this.mangaCache.forEach( ( manga ) => {
                        manga.updateStatus();
                    });
                    callback( null, this.mangaCache );
                    return;
                }
                // get manga list from the local storage and cache them
                Engine.Storage.loadMangaList( this.id, ( mangas, error ) => {
                    if( !error ) {
                        if( mangas ) {
                            // de-serialize mangas into objects
                            this.mangaCache = mangas.map( ( manga ) => {
                                return new Manga( this, manga.id, manga.title );
                            });
                        }
                    } else {
                        console.error( error.message );
                        this.mangaCache = undefined;
                    }
                    callback( null, this.mangaCache );
                });
            });
        }

        /**
         * Switch the connector to lock mode.
         * In lock mode the connector may limit concurrent access.
         * The limitation depends on the connector implementation.
         * Returns a key required to unlock the connector (only the owner with the key can unlock the connector)
         * or null if the connector is already locked by a different owner.
         */
        lock() {
            if( this.isLocked ) {
                return null;
            }
            this.isLocked = Symbol();
            return this.isLocked;
        }

        /**
         *
         */
        unlock( key ) {
            if( this.isLocked === key ) {
                this.isLocked = false;
            }
        }

        /**
         * Helper function to decrypt the protected email within the given DOM element.
         */
        cfMailDecrypt( element ) {
            [...element.querySelectorAll( 'span[data-cfemail]' )].forEach(  ( span ) => {
                let encrypted = span.getAttribute( 'data-cfemail' ); // span.dataset.cfmail
                if( encrypted ) {
                    // decrypt mail
                    let decrypted = '';
                    let key = '0x' + encrypted.substr(0, 2) | 0;
                    for ( let i=2; i<encrypted.length; i+=2) {
                        decrypted += '%' + ('0' + ('0x' + encrypted.substr(i, 2) ^ key).toString(16)).slice(-2);
                    }
                    span.replaceWith( decodeURIComponent( decrypted ) );
                }
            });
        }

        /**
         * Revert the expansion of relative links regardng the base url,
         * or leave the absolute url if the link seems not to been expanded.
         */
         getRelativeLink( element ) {
            if( element.href || element.src ) {
                let baseURI = new URL( this.url );
                let refURI = new URL( element.href || element.src );

                // case: element.href => protocol + host expanded to window location (e.g. /sub/page.html => protocol://window/sub/page.html)
                if( refURI.origin === window.location.origin ) {
                    refURI.hostname = baseURI.hostname;
                }

                // case: element.href => protocol expanded to window location (e.g. //domain.net/sub/page.html => protocol://domain.net/sub/page.html)
                // HakuNeko uses its own protocol for local hosted application files
                // expansion of hrefs may lead to wrong protocol for external links
                // => use the protocol of the connector's base url
                if( refURI.protocol === window.location.protocol ) {
                    refURI.protocol = baseURI.protocol;
                }

                // case: element.href => absolute link that contains base url of connector (e.g. http://onnector.net/sub/page.html)
                if( refURI.hostname === baseURI.hostname ) {
                    return (refURI.pathname + refURI.search + refURI.hash);
                } else {
                    return refURI.href;
                }
            }
        }

        /**
         * Create DOM (HTML element) from the given content.
         * Image tags can be replaced with source tags to prevent the 'src' attribute from loading its content (save bandwith, improve performance).
         * Atributes from iframe tags (espacially 'src') can be removed to prevent it from loading its content (save bandwith, improve performance).
         * NOTE: When loading content into DOM, all links without a full qualified domain name will be expanded using the hostname of this app
         *       => do not forget to remove this prefix from the links!
         */
        createDOM( content, replaceImageTags, clearIframettributes ) {
            replaceImageTags = ( replaceImageTags !== undefined ? replaceImageTags : true );
            clearIframettributes = ( clearIframettributes !== undefined ? clearIframettributes : true );
            if( replaceImageTags ) {
                content = content.replace( /<img/g, '<source');
                content = content.replace( /<\/img/g, '</source');
                content = content.replace( /<use/g, '<source');
                content = content.replace( /<\/use/g, '</source');
            }
            if( clearIframettributes ) {
                content = content.replace( /<iframe[^<]*?>/g, '<iframe>');
            }
            let dom = document.createElement( 'html' );
            dom.innerHTML = content;
            return dom;
        }

        /**
         * Determine if the request for the page is valid.
         * A request is invalid when it is made by the electron browser and
         * when the page for which this request is made is not part of the selected chapter
         * (in fact: the user changed the chapter while the browser still requests pages from the previous selected chapter).
         */
        isPageRequestNotFromElectronOrSelectedChapter( request ) {
            try {
                // is the request not from electron browser?
                if( !request.headers || !request.headers['User-Agent'] || request.headers['User-Agent'].indexOf( /*'hakuneko-desktop'*/ 'Electron' ) < 0 ) {
                    return true;
                }
                // is the currently selected chapter the one for which the page is requested?
                let selectedChapterPages = document.querySelector( HakunekoApp.is ).shadowRoot.querySelector( HakunekoPages.is ).selectedChapter.pageCache;
                return ( selectedChapterPages.indexOf( request.url ) > -1 );
            } catch( e ) {
                return false;
            }
        }
    }
    Connector; // reference the class to prevent removal of the class through js-minify

</script>