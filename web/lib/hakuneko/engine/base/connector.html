<link rel="import" href="enums.html">
<link rel="import" href="manga.html">
<link rel="import" href="useragent.html">

<script>

    /**
     * Base class for connector plugins
     */
    class Connector {

        /**
         *
         */
        constructor() {
            this.id = Symbol();
            this.label = '';
            this.tags = [];
            // READONLY: lock state may used to prevent to many concurrent requests per second
            // do not set directly, use lock() and unlock()
            this.isLocked = false;
            this.initialized = false;
            //
            this.isUpdating = false;
            //
            this.mangaCache = undefined;
            //
            this.existingMangas = [];
            // initialize the default request options
            // https://developer.mozilla.org/en-US/docs/Web/API/Request/Request 'init' parameter
            this.requestOptions = {
                method: 'GET',
                mode: 'cors',
                redirect: 'follow',
                // include credentials to apply cookies from browser window
                credentials: 'same-origin', // 'include',
                headers: new Headers()
                // body
                // cache
                // referrer
                // integrity
            };
        }

        /**
         *
         */
        get icon() {
            return '/img/connectors/' + this.id;
        }

        /**
         * See: this._initialize()
         * This method can be overwritten by the connector for a specific implementation of the initialization process
         */
        _initializeConnector() {
            // sometimes cloudflare bypass will fail, because chrome successfully loads the page from its cache
            // => append random search parameter to avoid caching
            let uri = new URL( this.url );
            uri.searchParams.set( 'ts', Date.now() );
            uri.searchParams.set( 'rd', Math.random() );
            let request = new Request( uri.href, this.requestOptions );
            return Engine.Request.fetchUI( request, '' );
        }

        /**
         *
         */
        initialize() {
            return Promise.resolve()
            .then( () => {
                if( this.initialized ) {
                    return Promise.resolve();
                } else {
                    return this._initializeConnector();
                }
            } )
            .then( () => {
                this.initialized = true;
            } )
            .catch( error => {
                this.initialized = false;
                // in offline mode set initialization to false, but do not throw
                if( error.stack.startsWith( 'ERR_INTERNET_DISCONNECTED' ) ) {
                    //console.warn( 'Initialization Failed', this, JSON.stringify(error) );
                    return Promise.resolve();
                }
                throw error;
            } );
        }

        /**
         * Find first manga with title that matches the given pattern (case-insensitive).
         */
        findMatchingManga( pattern ) {
            let needle = pattern.toLowerCase();
            return Engine.Storage.loadMangaList( this.id )
            .then( mangas => {
                return Promise.resolve( mangas.find( manga => manga.title.toLowerCase().includes( needle ) ) );
            } )
            .catch( error => Promise.resolve( undefined ) );
        }

        /**
         * Update the manga list in the local storage.
         * Callback will be executed after completion and provided with a reference to the manga list (undefined on error).
         */
        updateMangas( callback ) {
            if( this.isUpdating ) {
                return;
            }
            this.isUpdating = true;
            this.initialize()
            .then( () => {
                this._getMangaList( ( error, mangas ) => {
                    if( error || !mangas ) {
                        this.isUpdating = false;
                        callback( error, undefined );
                        return;
                    }
                    // remove duplicates by checking if manga with given ID is first occurance in list
                    mangas = mangas.filter( ( manga, index ) => {
                        return index === mangas.findIndex( m => m.id === manga.id );
                    } );
                    // sort by title
                    mangas.sort( ( a, b ) => {
                        return ( a.title.toLowerCase() < b.title.toLowerCase() ? -1 : 1 );
                    } );
                    
                    this.mangaCache = undefined;
                    Engine.Storage.saveMangaList( this.id, mangas )
                    .then( () => {
                        // NOTE: connector.isUpdating must be set before the callback, because callback receiver relies on it
                        this.isUpdating = false;
                        this.getMangas( callback );
                    } )
                    .catch( error => {
                        // NOTE: connector.isUpdating must be set before the callback, because callback receiver relies on it
                        this.isUpdating = false;
                        console.error( error.message );
                        callback( error, undefined );
                    } );
                } );
            } )
            .catch( error => {
                // NOTE: connector.isUpdating must be set before the callback, because callback receiver relies on it
                this.isUpdating = false;
                callback( error, undefined );
            } );
        }

        /**
         * Get all mangas for the connector.
         * Callback will be executed after completion and provided with a reference to the manga list (undefined on error).
         */
        getMangas( callback ) {
            // find all manga titles (sanitized) that are found in the base directory for this connector
            return Engine.Storage.getExistingMangaTitles( this )
            .catch( error => {
                // Ignore manga file reading errors (e.g. root directory not exist)
                //console.warn( 'getMangas', error );
                return Promise.resolve( [] );
            } )
            .then( existingMangaTitles => {
                this.existingManga = existingMangaTitles;
                // check if manga list is cached
                return ( this.mangaCache && this.mangaCache.length ? this._getUpdatedMangasFromCache() : this._getUpdatedMangasFromFile() );
            } )
            .then( mangas => {
                callback( null, mangas );
                return Promise.resolve( mangas );
            } )
            .catch( error => {
                // TODO: remove log ... ?
                console.warn( 'getMangas', error );
                callback( error, this.mangaCache );
                return Promise.reject( error );
            } );
        }

        /**
         * See: this.getMangaFromURI( uri )
         * This method can be overwritten by connector implementations.
         */
        _getMangaFromURI( uri ) {
            return new Promise( ( resolve, reject ) => {
                let id = uri.pathname + uri.search;
                let title = 'Untitled #' + Date.now().toString( 16 ).slice( -6 ).toUpperCase();
                resolve( new Manga( this, id, title ) );
            } );
        }

        /**
         * Returns a promise that resolves with a manga on success or resolves with an error on failure.
         * The promise will NOT reject!
         */
        getMangaFromURI( uri ) {
            // TODO: try to find title in cached manga list first
            //       => this.getMangas().then( ... )
            return this.initialize()
            .then( () => this._getMangaFromURI( uri ) )
            .catch( error => {
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getUpdatedMangasFromCache() {
            if( this.mangaCache ) {
                this.mangaCache.forEach( manga => {
                    manga.updateStatus();
                } );
            }
            return Promise.resolve( this.mangaCache );
        }

        /**
         *
         */
        _getUpdatedMangasFromFile() {
            // get manga list from the local storage and cache them
            return Engine.Storage.loadMangaList( this.id )
            .then( mangas => {
                // de-serialize mangas into objects
                this.mangaCache = mangas.map( manga => {
                    return new Manga( this, manga.id, manga.title );
                } );
                return Promise.resolve( this.mangaCache );
            } )
            .catch( error => {
                // TODO: remove log ... ?
                console.warn( '_getUpdatedMangasFromFile', error );
                return Promise.resolve( this.mangaCache || [] );
            } );
        }

        /**
         * Return a promise that will be resolved after the given amount of time in milliseconds
         */
        wait( time ) {
            return new Promise( ( resolve, reject ) => {
                setTimeout( resolve, time );
            } );
        }

        /**
         * Switch the connector to lock mode.
         * In lock mode the connector may limit concurrent access.
         * The limitation depends on the connector implementation.
         * Returns a key required to unlock the connector (only the owner with the key can unlock the connector)
         * or null if the connector is already locked by a different owner.
         */
        lock() {
            if( this.isLocked ) {
                return null;
            }
            this.isLocked = Symbol();
            return this.isLocked;
        }

        /**
         *
         */
        unlock( key ) {
            if( this.isLocked === key ) {
                this.isLocked = false;
            }
        }

        /**
         * Helper function to decrypt the protected email within the given DOM element.
         */
        cfMailDecrypt( element ) {
            [...element.querySelectorAll( 'span[data-cfemail]' )].forEach(  ( span ) => {
                let encrypted = span.getAttribute( 'data-cfemail' ); // span.dataset.cfmail
                if( encrypted ) {
                    // decrypt mail
                    let decrypted = '';
                    let key = '0x' + encrypted.substr(0, 2) | 0;
                    for ( let i=2; i<encrypted.length; i+=2) {
                        decrypted += '%' + ('0' + ('0x' + encrypted.substr(i, 2) ^ key).toString(16)).slice(-2);
                    }
                    span.replaceWith( decodeURIComponent( decrypted ) );
                }
            });
        }

        /**
         * [OBSOLETE => use getRootRelativeLink( element, base )]
         * Revert the expansion of relative links regarding the base url,
         * or leave the absolute url if the link seems not to been expanded.
         */
         getRelativeLink( element ) {
            if( element.href || element.src ) {
                let baseURI = new URL( this.url );
                let refURI = new URL( element.href || element.src );

                // case: element.href => protocol + host expanded to window location (e.g. /sub/page.html => protocol://window/sub/page.html)
                if( refURI.origin === window.location.origin ) {
                    refURI.hostname = baseURI.hostname;
                }

                // case: element.href => protocol expanded to window location (e.g. //domain.net/sub/page.html => protocol://domain.net/sub/page.html)
                // HakuNeko uses its own protocol for local hosted application files
                // expansion of hrefs may lead to wrong protocol for external links
                // => use the protocol of the connector's base url
                if( refURI.protocol === window.location.protocol ) {
                    refURI.protocol = baseURI.protocol;
                }

                // case: element.href => absolute link that contains base url of connector (e.g. http://connector.net/sub/page.html)
                if( refURI.hostname === baseURI.hostname ) {
                    return (refURI.pathname + refURI.search + refURI.hash);
                } else {
                    return refURI.href;
                }
            }
        }

        /**
         * 
         */
        getAbsolutePath( reference, base ) {
            let baseURI;
            switch( true ) {
                case base instanceof URL:
                    baseURI = base;
                    break;
                case typeof base === 'string':
                    baseURI = new URL( base );
                    break;
                default:
                    throw new Error( 'Failed to extract relative link (parameter "base" is invalid)!' );
            }

            let refURI;
            switch( true ) {
                case reference instanceof URL:
                    refURI = reference;
                    break;
                case typeof reference === 'string':
                    refURI = new URL( reference, baseURI.href );
                    break;
                case reference['src'] !== undefined:
                    refURI = new URL( reference.getAttribute( 'src' ), baseURI.href );
                    break;
                case reference['href'] !== undefined:
                    refURI = new URL( reference.getAttribute( 'href' ), baseURI.href );
                    break;
                default:
                    throw new Error( 'Failed to extract relative link (parameter "reference" is invalid)!' );
            }

            return refURI.href;
        }

        /**
         * 
         */
        getRootRelativeOrAbsoluteLink( reference, base ) {
            let uri = new URL( this.getAbsolutePath( reference, base ) );
            // FIXME: this is always true ...
            if( uri.hostname === uri.hostname ) {
                // same doamin => return only path
                return uri.pathname + uri.search + uri.hash;
            } else {
                // cross domain => return absolute link
                return uri.href;
            }
        }

        /**
         * Create DOM (HTML element) from the given content.
         * Image tags can be replaced with source tags to prevent the 'src' attribute from loading its content (save bandwith, improve performance).
         * Atributes from iframe tags (espacially 'src') can be removed to prevent it from loading its content (save bandwith, improve performance).
         * NOTE: When loading content into DOM, all links without a full qualified domain name will be expanded using the hostname of this app
         *       => do not forget to remove this prefix from the links!
         */
        createDOM( content, replaceImageTags, clearIframettributes ) {
            replaceImageTags = ( replaceImageTags !== undefined ? replaceImageTags : true );
            clearIframettributes = ( clearIframettributes !== undefined ? clearIframettributes : true );
            if( replaceImageTags ) {
                content = content.replace( /<img/g, '<source');
                content = content.replace( /<\/img/g, '</source');
                content = content.replace( /<use/g, '<source');
                content = content.replace( /<\/use/g, '</source');
            }
            if( clearIframettributes ) {
                content = content.replace( /<iframe[^<]*?>/g, '<iframe>');
            }
            let dom = document.createElement( 'html' );
            dom.innerHTML = content;
            return dom;
        }

        /**
         * Get the content for the given Request
         * and get all elements matching the given CSS selector.
         */
        fetchDOM( request, selector, retries ) {
            retries = retries || 0;
            if( typeof request === 'string' ) {
                request = new Request( request, this.requestOptions );
            }
            // TODO: check if this will affect (replace) the input parameter?
            if( request instanceof URL ) {
                request = new Request( request.href, this.requestOptions );
            }
            return fetch( request )
            .then( response => {
                if( response.status >= 500 && retries > 0 ) {
                    return this.wait( 5000 )
                    .then( () => this.fetchDOM( request, selector, retries - 1 ) );
                }
                if( response.status === 200 ) {
                    return response.text()
                    .then( data => {
                        let dom = this.createDOM( data );
                        return Promise.resolve( [...dom.querySelectorAll( selector )] );
                    } );
                }
                throw new Error( `Failed to receive content from "${request.url}" (status: ${response.status}) - ${response.statusText}` );
            } );
        }

        /**
         *
         */
        fetchJSON( request, retries ) {
            retries = retries || 0;
            if( typeof request === 'string' ) {
                request = new Request( request, this.requestOptions );
            }
            // TODO: check if this will affect (replace) the input parameter?
            if( request instanceof URL ) {
                request = new Request( request.href, this.requestOptions );
            }
            return fetch( request )
            .then( response => {
                if( response.status >= 500 && retries > 0 ) {
                    return this.wait( 5000 )
                    .then( () => this.fetchJSON( request, retries - 1 ) );
                }
                if( response.status === 200 ) {
                    return response.json();
                }
                throw new Error( `Failed to receive content from "${request.url}" (status: ${response.status}) - ${response.statusText}` );
            } );
        }

        /**
         * Protected helper function to convert a Blob to a MimeTypedBuffer
         * https://github.com/electron/electron/blob/master/docs/api/protocol.md#protocolregisterbufferprotocolscheme-handler-completion
         */
        _blobToBuffer( blob ) {
            return new Promise( ( resolve, reject ) => {
                let reader = new FileReader();
                reader.onload = event => {
                    resolve( {
                        mimeType: blob.type,
                        // NOTE: Uint8Array() seems slightly better than Buffer.from(), but both are blazing fast
                        data: Buffer.from( event.target.result ) // new Uint8Array( event.target.result )
                    } );
                };
                reader.onerror = event => {
                    reject( event.target.error );
                }
                reader.readAsArrayBuffer( blob );
            } );
        }

        /**
         * Apply the real mime type to the MimeTypedBuffer (based on file signature).
         */
        _applyRealMime( data ) {
            // WEBP [52 49 46 46 . . . . 57 45 42 50]
            if( data.mimeType !== 'image/webp' && data.data[8] === 0x57 && data.data[9] === 0x45 && data.data[10] === 0x42 && data.data[11] === 0x50 ) {
                console.warn( 'Provided mime type "' + data.mimeType + '" does not match the file signature and was replaced by "image/webp"!' );
                data.mimeType = 'image/webp';
            }
            // JPEG [FF D8 FF]
            if( data.mimeType !== 'image/jpeg' && data.data[0] === 0xFF && data.data[1] === 0xD8 && data.data[2] === 0xFF ) {
                console.warn( 'Provided mime type "' + data.mimeType + '" does not match the file signature and was replaced by "image/jpeg"!' );
                data.mimeType = 'image/jpeg';
            }
            // PNG [. 50 4E 47]
            if( data.mimeType !== 'image/png' && data.data[1] === 0x50 && data.data[2] === 0x4E && data.data[3] === 0x47 ) {
                console.warn( 'Provided mime type "' + data.mimeType + '" does not match the file signature and was replaced by "image/png"!' );
                data.mimeType = 'image/png';
            }
            // GIF [47 49 46]
            if( data.mimeType !== 'image/gif' && data.data[0] === 0x47 && data.data[1] === 0x49 && data.data[2] === 0x46 ) {
                console.warn( 'Provided mime type "' + data.mimeType + '" does not match the file signature and was replaced by "image/gif"!' );
                data.mimeType = 'image/gif';
            }
            // BMP [42 4D]
            if( data.mimeType !== 'image/bmp' && data.data[0] === 0x42 && data.data[1] === 0x4D ) {
                console.warn( 'Provided mime type "' + data.mimeType + '" does not match the file signature and was replaced by "image/bmp"!' );
                data.mimeType = 'image/bmp';
            }
        }

        /**
         * [OBSOLETE] with usage of fetch API and modified User-Agent, this check is no longer reliable
         * 
         * Determine if the request for the page is valid.
         * A request is invalid when it is made by the electron browser and
         * when the page for which this request is made is not part of the selected chapter
         * (in fact: the user changed the chapter while the browser still requests pages from the previous selected chapter).
         */
        isPageRequestNotFromElectronOrSelectedChapter( request ) {
            try {
                // is the request not from electron browser?
                if( !request.headers || !request.headers['User-Agent'] || request.headers['User-Agent'].indexOf( /*'hakuneko-desktop'*/ 'Electron' ) < 0 ) {
                    return true;
                }
                // is the currently selected chapter the one for which the page is requested?
                let selectedChapterPages = document.querySelector( HakunekoApp.is ).shadowRoot.querySelector( HakunekoPages.is ).selectedChapter.pageCache;
                return ( selectedChapterPages.indexOf( request.url ) > -1 );
            } catch( e ) {
                return false;
            }
        }
    }
    Connector; // reference the class to prevent removal of the class through js-minify

</script>