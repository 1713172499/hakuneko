<link rel="import" href="../connector.html">

<script>

    /**
     * 
     */
    class NineAnime extends Connector {

        /**
         *
         */
        constructor() {
            super();
            // Public members for usage in UI (mandatory)
            super.id         = '9anime';
            super.label      = '9ANIME';
            this.tags        = [ 'anime', 'english' ];
            super.isLocked   = false;
            // Private members for internal usage only (convenience)
            this.url         = 'https://www3.9anime.to';
            this.requestOptions.headers.set( 'x-referer', this.url );
            // Private members for internal use that can be configured by the user through settings menu (set to undefined or false to hide from settings menu!)
            this.config = {
                resolution:  {
                    label: 'Preferred Resolution',
                    description: 'Try to download video in the selected resolution.\nIf the resolution is not supported, depending on the mirror the download may fail, or a fallback resolution may be used!',
                    input: Input.select,
                    options: [
                        { value: '', name: 'Mirror\'s Default' },
                        { value: '480', name: '480p' },
                        { value: '720', name: '720p' },
                        { value: '1080', name: '1080p' }
                    ],
                    value: ''
                }
            };
        }
        
        /**
         *
         */
        get timestamp() {
            return Date.now().toString().slice( 0, -3 ).padEnd( 10, '0' );
        }

        /**
         * Overwrite base function to get manga from clipboard link.
         */
        _getMangaFromURI( uri ) {
            return fetch( uri.href, this.requestOptions )
            .then( response => response.text() )
            .then( data => {
                let dom = this.createDOM( data );
                let metaURL = dom.querySelector( 'meta[property="og:url"]' ).content.trim();
                let metaTitle = dom.querySelector( 'div.head h2[data-jtitle].title' ); // 'meta[property="og:title"]'
                let id = this.getRootRelativeOrAbsoluteLink( metaURL, uri.href );
                let title = metaTitle.dataset.jtitle.trim();
                return Promise.resolve( new Manga( this, id, title ) );
            } )
            .catch( error => {
                console.error( error );
            } )
        }

        /**
         *
         */
        _getMangaListFromPages( mangaPageLinks, index ) {
            if( index === undefined ) {
                index = 0;
            }
            return this.wait( 0 )
            .then ( () => this.fetchDOM( mangaPageLinks[ index ], 'div.film-list div.item div.inner a.name', 5 ) )
            .then( data => {
                let mangaList = data.map( element => {
                    return {
                        id: this.getRelativeLink( element ),
                        title: element.text.trim()
                    };
                } );
                if( index < mangaPageLinks.length - 1 ) {
                    return this._getMangaListFromPages( mangaPageLinks, index + 1 )
                    .then( mangas => mangas.concat( mangaList ) );
                } else {
                    return Promise.resolve( mangaList );
                }
            } );
        }

        /**
         *
         */
        _getMangaList( callback ) {
            this.fetchDOM( this.url + '/filter', 'div.paging-wrapper form span.total' )
            .then( data => {
                let pageCount = parseInt( data[0].textContent.trim() );
                let pageLinks = [...( new Array( pageCount ) ).keys()].map( page => this.url + '/filter?page=' + ( page + 1 ) );
                return this._getMangaListFromPages( pageLinks );
            } )
            .then( data => {
                callback( null, data );
            } )
            .catch( error => {
                console.error( error, this );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getChapterList( manga, callback ) {
            let animeID = manga.id.split( '.' ).pop();
            this.fetchJSON( `${ this.url }/ajax/film/servers/${ animeID }?ts=${ this.timestamp }` )
            .then( data => {
                let dom = this.createDOM( data.html );
                let servers = [...dom.querySelectorAll( 'div.servers span.tab' )]
                .map( element => {
                    return {
                        name: element.dataset.name,
                        label: element.innerText.trim()
                    };
                } );
                let chapterList = [...dom.querySelectorAll( 'div.servers div.server' )]
                .reduce( ( accumulator, server ) => {
                    let episodes = [...server.querySelectorAll( 'ul.episodes li a' )]
                    .map( episode => {
                        return {
                            id: this.getRootRelativeOrAbsoluteLink( episode, this.url ),
                            title: `${ episode.text.trim() } [${ servers.find( s => s.name === server.dataset.name ).label }]`,
                            language: ''
                        };
                    } );
                    return accumulator.concat( episodes );
                }, [] );
                callback( null, chapterList );
            } )
            .catch( error => {
                console.error( error, manga );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getPageList( manga, chapter, callback ) {
            let animeID = manga.id.split( '.' ).pop();
            let episodeID = chapter.id.split( '/' ).pop();
            this.fetchJSON( `${ this.url }/ajax/film/servers/${ animeID }?episode=${ episodeID }&ts=${ this.timestamp }` )
            .then( data => {
                let dom = this.createDOM( data.html );
                let server = dom.querySelector( 'div.servers div.server.active' ).dataset;
                let episode = dom.querySelector( 'div.servers div.server.active ul.episodes li a.active' ).dataset;
                let uri = `${ this.url }/ajax/episode/info?server=${ server.id }&id=${ episode.id }&ts=${ this.timestamp }`;
                return Promise.resolve( uri );
            } )
            .then( uri => {
                this.requestOptions.headers.set( 'x-requested-with', 'XMLHttpRequest' );
                let promise = this.fetchJSON( uri );
                this.requestOptions.headers.delete( 'x-requested-with' );
                return promise;
            } )
            .then( data => {
                switch(true) {
                    case data.target.includes( 'prettyfast.to' ):
                        return this._getEpisodePrettyFast( data.target, this.config.resolution.value );
                    case data.target.includes( 'rapidvideo.com' ):
                        return this._getEpisodeRapidVideo( data.target, this.config.resolution.value );
                    case data.target.includes( 'openload.co' ):
                        return this._getEpisodeOpenLoad( data.target, this.config.resolution.value );
                    case data.target.includes( 'mcloud.to' ):
                        return this._getEpisodeMyCloud( data.target, this.config.resolution.value );
                    case data.target.includes( 'mp4upload.com' ):
                        return this._getEpisodeMp4upload( data.target, this.config.resolution.value );
                    case data.target.includes( 'streamango.com' ):
                        return this._getEpisodeStreamango( data.target, this.config.resolution.value );
                    default:
                        throw new Error( 'Support for video stream from mirror "' + data.target + '" not implemented!' );
                }
            } )
            .then( media => {
                callback( null, media );
            } )
            .catch( error => {
                console.error( error, chapter );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getEpisodePrettyFast( link, resolution ) {
            let promise = fetch( link, this.requestOptions )
            .then( response => response.text() )
            .then( result => {
                let playlist = result.match( /playlist\s*:\s*\[\s*\{\s*file:\s*['"]([^'"]+)['"]/ )[1];
                return Promise.resolve( { hash: 'id,language,resolution', mirrors: [ playlist ], subtitles: [] } );
            } );
            return promise;
        }

        /**
         * Same as in kissanime
         */
        _getEpisodeRapidVideo( link, resolution ) {
            this.requestOptions.headers.set( 'x-cookie', 'q=' + resolution );
            let promise = this.fetchDOM( link, 'video#videojs source' )
            .then( data => {
                if( !data.length ) {
                    throw new Error( `No matching video stream found for requested resolution "${resolution}"!` );
                }
                return Promise.resolve( { video: data[0].src, subtitles: [] } );
            } );
            this.requestOptions.headers.delete( 'x-cookie' );
            return promise;
        }

        /**
         *
         */
        _getEpisodeOpenLoad( link, resolution ) {
            let script = `
                document.querySelector('div#videooverlay').click();
                document.querySelector('video[id^="olvideo"]').src;
            `;
            return Engine.Request.fetchUI( link, this.requestOptions, script )
            .then( stream => {
                return Promise.resolve( { video: stream, subtitles: [] } );
            } );
        }

        /**
         *
         */
        _getEpisodeMyCloud( link, resolution ) {
            return fetch( link, this.requestOptions )
            .then( response => response.text() )
            .then( result => {
                let playlist = result.match( /sources\s*:\s*\[\s*\{\s*"file"\s*:\s*"(.*?)"/ )[1];
                this.requestOptions.headers.set( 'x-referer', link );
                let promise = fetch( playlist, this.requestOptions )
                .then( response => response.text() )
                .then( streamlist => {
                    let stream = streamlist.match( /^.*?\d+\.m3u8$/gm )[0].trim();
                    // stream => hls/480/480.m3u8 || hls/720/720.m3u8 || ...
                    stream = playlist.replace( /[^\/]+$/, stream );
                    return Promise.resolve( { hash: 'id,language,resolution', mirrors: [ stream ], subtitles: [] } );
                } );
                this.requestOptions.headers.set( 'x-referer', this.url );
                return promise;
            } );
        }

        /**
         *
         */
        _getEpisodeMp4upload( link, resolution ) {
            // NOT WORKING: missing content-length header when downloading stream (fetch CORS problem)
            return Engine.Request.fetchUI( link, this.requestOptions, `document.querySelector('div#player div.jw-media video.jw-video').src;` )
            .then( stream => {
                return Promise.resolve( { video: stream, subtitles: [] } );
            } );
        }

        /**
         *
         */
        _getEpisodeStreamango( link, resolution ) {
            return Engine.Request.fetchUI( link, this.requestOptions, `document.querySelector('video[id^="mgvideo"]').src;` )
            .then( stream => {
                return Promise.resolve( { video: stream, subtitles: [] } );
            } );
        }
    }

</script>