<link rel="import" href="../connector.html">

<script>

    /**
     * 
     */
    class NineAnime extends Connector {

        /**
         *
         */
        constructor() {
            super();
            // Public members for usage in UI (mandatory)
            super.id         = '9anime';
            super.label      = '9ANIME';
            this.tags        = [ 'anime', 'english' ];
            super.isLocked   = false;
            // Private members for internal usage only (convenience)
            this.url         = 'https://www3.9anime.to';
            // Private members for internal use that can be configured by the user through settings menu (set to undefined or false to hide from settings menu!)
            this.config = {
                resolution:  {
                    label: 'Preferred Resolution',
                    description: 'Try to download video in the selected resolution.\nIf the resolution is not supported, depending on the mirror the download may fail, or a fallback resolution may be used!',
                    input: Input.select,
                    options: [
                        { value: '', name: 'Mirror\'s Default' },
                        { value: '480', name: '480p' },
                        { value: '720', name: '720p' },
                        { value: '1080', name: '1080p' }
                    ],
                    value: ''
                }
            };
        }

        /**
         *
         */
        _getMangaListFromPages( mangaPageLinks, index ) {
            if( index === undefined ) {
                index = 0;
            }
            return this.wait( 0 )
            .then ( () => this.fetchDOM( mangaPageLinks[ index ], 'div.film-list div.item div.inner a.name', 5 ) )
            .then( data => {
                let mangaList = data.map( element => {
                    return {
                        id: this.getRelativeLink( element ),
                        title: element.text.trim()
                    };
                } );
                if( index < mangaPageLinks.length - 1 ) {
                    return this._getMangaListFromPages( mangaPageLinks, index + 1 )
                    .then( mangas => mangas.concat( mangaList ) );
                } else {
                    return Promise.resolve( mangaList );
                }
            } );
        }

        /**
         *
         */
        _getMangaList( callback ) {
            this.fetchDOM( this.url + '/filter', 'div.paging-wrapper form span.total' )
            .then( data => {
                let pageCount = parseInt( data[0].textContent.trim() );
                let pageLinks = [...( new Array( pageCount ) ).keys()].map( page => this.url + '/filter?page=' + ( page + 1 ) );
                return this._getMangaListFromPages( pageLinks );
            } )
            .then( data => {
                callback( null, data );
            } )
            .catch( error => {
                console.error( error, this );
                callback( error, undefined );
            } );
        }
        
        /**
         *
         */
        _getScript( active ) {
            return `
            new Promise( ( resolve, reject ) => {
                setTimeout( () => {
                    let servers = [...document.querySelectorAll( 'div#servers-container div.servers span.tabs span.tab' )]
                    .map( span => {
                        let id = span.dataset['name'];
                        return {
                            id: id,
                            label: span.textContent.trim(),
                            episodes: [...document.querySelectorAll( 'div#servers-container div.servers div.server[data-name="' + id + '"] ul.episodes li a${ active ? '.active' : '' }' )]
                            .map( a => {
                                return {
                                    id: a['dataset']['id'] || a.href.split( '/' ).pop(),
                                    url: a.href,
                                    title: a.text.trim()
                                };
                            } )
                        };
                    } );
                    resolve( servers );
                }, 2500 );
            } )
            `;
        }

        /**
         *
         */
        _getChapterList( manga, callback ) {
            Engine.Request.fetchUI( this.url + manga.id, this.requestOptions, this._getScript( false ) )
            .then( result => {
                let chapterList = result.reduce( ( accumulator, server ) => {
                    let episodes = server.episodes.map( episode => {
                        return {
                            id: this.getRootRelativeOrAbsoluteLink( episode.url, this.url ),
                            title: `${episode.title} [${server.label}]`,
                            language: ''
                        };
                    } );
                    return accumulator.concat( episodes );
                }, [] );
                callback( null, chapterList );
            } )
            .catch( error => {
                console.error( error, manga );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getPageList( manga, chapter, callback ) {
            Engine.Request.fetchUI( this.url + chapter.id, this.requestOptions, this._getScript( true ) )
            .then( result => {
                for( let server of result ) {
                    for( let episode of server.episodes ) {
                        let uri = this.url + '/ajax/episode/info?server=' + server.id + '&id=' + episode.id;
                        return Promise.resolve( uri );
                    }
                }
                throw new Error( 'Episode not found!' );
            } )
            .then( uri => fetch( ( uri + '&ts=' + Date.now() ).slice( 0, -3 ), this.requestOptions ) )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive JSON (status: ${response.status}) - ${response.statusText}` );
                }
                return response.json();
            } )
            .then( data => {
                switch(true) {
                    case data.target.includes( 'prettyfast.to' ):
                        return this._getEpisodePrettyFast( data.target, this.config.resolution.value );
                    case data.target.includes( 'rapidvideo.com' ):
                        return this._getEpisodeRapidVideo( data.target, this.config.resolution.value );
                    case data.target.includes( 'openload.co' ):
                        return this._getEpisodeOpenLoad( data.target, this.config.resolution.value );
                    case data.target.includes( 'mcloud.to' ):
                        return this._getEpisodeMyCloud( data.target, this.config.resolution.value );
                    case data.target.includes( 'mp4upload.com' ):
                        return this._getEpisodeMp4upload( data.target, this.config.resolution.value );
                    case data.target.includes( 'streamango.com' ):
                        return this._getEpisodeStreamango( data.target, this.config.resolution.value );
                    default:
                        throw new Error( 'Support for video stream from mirror "' + data.target + '" not implemented!' );
                }
            } )
            .then( media => {
                callback( null, media );
            } )
            .catch( error => {
                console.error( error, chapter );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getEpisodePrettyFast( link, resolution ) {
            this.requestOptions.headers.set( 'x-referer', this.url );
            let promise = fetch( link, this.requestOptions )
            .then( response => response.text() )
            .then( result => {
                let playlist = result.match( /playlist\s*:\s*\[\s*\{\s*file:\s*['"]([^'"]+)['"]/ )[1];
                return Promise.resolve( { hash: 'id,language,resolution', mirrors: [ playlist ], subtitles: [] } );
            } );
            this.requestOptions.headers.delete( 'x-referer' );
            return promise;
        }

        /**
         * Same as in kissanime
         */
        _getEpisodeRapidVideo( link, resolution ) {
            this.requestOptions.headers.set( 'x-cookie', 'q=' + resolution );
            let promise = this.fetchDOM( link, 'video#videojs source' )
            .then( data => {
                if( !data.length ) {
                    throw new Error( `No matching video stream found for requested resolution "${resolution}"!` );
                }
                return Promise.resolve( { video: data[0].src, subtitles: [] } );
            } );
            this.requestOptions.headers.delete( 'x-cookie' );
            return promise;
        }

        /**
         *
         */
        _getEpisodeOpenLoad( link, resolution ) {
            let script = `
                document.querySelector('div#videooverlay').click();
                document.querySelector('video[id^="olvideo"]').src;
            `;
            return Engine.Request.fetchUI( link, this.requestOptions, script )
            .then( stream => {
                return Promise.resolve( { video: stream, subtitles: [] } );
            } );
        }

        /**
         *
         */
        _getEpisodeMyCloud( link, resolution ) {
            return fetch( link, this.requestOptions )
            .then( response => response.text() )
            .then( result => {
                let playlist = result.match( /sources\s*:\s*\[\s*\{\s*"file"\s*:\s*"(.*?)"/ )[1];
                return fetch( playlist, this.requestOptions )
                .then( response => response.text() )
                .then( streamlist => {
                    let stream = streamlist.match( /^.*?\d+\.m3u8$/gm )[0].trim();
                    // stream => hls/480/480.m3u8 || hls/720/720.m3u8 || ...
                    stream = playlist.replace( /[^\/]+$/, stream );
                    return Promise.resolve( { hash: 'id,language,resolution', mirrors: [ stream ], subtitles: [] } );
                } );
            } );
        }

        /**
         *
         */
        _getEpisodeMp4upload( link, resolution ) {
            // NOT WORKING: missing content-length header when downloading stream (fetch CORS problem)
            return Engine.Request.fetchUI( link, this.requestOptions, `document.querySelector('div#player div.jw-media video.jw-video').src;` )
            .then( stream => {
                return Promise.resolve( { video: stream, subtitles: [] } );
            } );
        }

        /**
         *
         */
        _getEpisodeStreamango( link, resolution ) {
            return Engine.Request.fetchUI( link, this.requestOptions, `document.querySelector('video[id^="mgvideo"]').src;` )
            .then( stream => {
                return Promise.resolve( { video: stream, subtitles: [] } );
            } );
        }
    }

</script>