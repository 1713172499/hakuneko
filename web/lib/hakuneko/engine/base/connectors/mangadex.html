<link rel="import" href="../connector.html">

<script>

    /**
     *
     */
    class MangaDex extends Connector {

        /**
         *
         */
        constructor() {
            super();
            // Public members for usage in UI (mandatory)
            super.id         = 'mangadex';
            super.label      = 'MangaDex';
            super.isLocked   = false;
            this.initialized = undefined;
            // Private members for internal usage only (convenience)
            this.url         = 'https://mangadex.org';
            this.requestOptions = {
                method: 'GET',
                mode: 'cors',
                redirect: 'follow',
                // include credentials to apply cookies from browser window
                credentials: 'include',
                headers: new Headers( {
                    // Due to a bug in chrome user-agent cannot be set
                    // => use a custom header to overwrite the agent in the 'onBeforeSendHeaders' event
                    'X-User-Agent': UserAgent.random()
                } )
            };
            // Private members for internal use that can be configured by the user through settings menu (set to undefined or false to hide from settings menu!)
            this.config = undefined;
        }

        /**
         *
         */
        _getMangaList( callback ) {
            window.fetch( 'http://' + this.id + '.hakuneko.download/cdn/mangas.json', this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive manga list (status: ${response.status}) - ${response.statusText}` );
                }
                return response.json();
            } )
            .then( data => {
                callback( null, data );
            } )
            .catch( error => {
                console.error( error, this );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getChapterList( manga, callback, chapterList, page ) {
            chapterList = chapterList || [];
            page = page || 1;
            window.fetch( this.url + manga.id + '/chapters/' + page + '/', this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive chapter list (status: ${response.status}) - ${response.statusText}` );
                }
                return response.text();
            } )
            .then( data => {
                    let dom = this.createDOM( data );
                    let chapters = [...dom.querySelectorAll( 'div.table-responsive tr[id]' )];
                    // abort when there are no chapters
                    if( !chapters || chapters.length === 0 ) {
                        callback( null, chapterList );
                        return;
                    }
                    chapters = chapters.map( ( element ) => {
                        let chapterInfo = element.querySelector( 'td:nth-of-type(2) a' );
                        let languageInfo = element.querySelector( 'td:nth-of-type(4) source' );
                        let scanlatorInfo = element.querySelector( 'td:nth-of-type(5) a' );
                        return {
                            id: this.getRelativeLink( chapterInfo ),
                            title: `Vol. ${chapterInfo.dataset.volumeNum} Ch. ${chapterInfo.dataset.chapterNum} - ${chapterInfo.dataset.chapterName} [${scanlatorInfo.text.trim()}]`,
                            language: languageInfo.title
                        };
                    });
                    // abort when the first chapter is already in the chapter list (already processed this chapter list)
                    if( chapterList.find( c => c.id === chapters[0].id ) ) {
                        callback( null, chapterList );
                        return;
                    }
                    chapterList = chapterList.concat( chapters );
                    this._getChapterList( manga, callback, chapterList, page+1 );
            } )
            .catch( error => {
                console.error( error, manga );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getPageList( manga, chapter, callback ) {
            window.fetch( this.url + chapter.id, this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive page list (status: ${response.status}) - ${response.statusText}` );
                }
                return response.text();
            } )
            .then( data => {
                let path = data.match( /var\s+server\s*=\s*['"]{1}(.+?)['"]{1}/ );
                let id = data.match( /var\s+dataurl\s*=.+?([a-f0-9)]+)/ );
                let pages = data.match( /var\s+page_array\s*=\s*\[\s*(.+?)\s*\]/ );
                if( !path || path.length < 2 || !id || id.length < 2 || !pages || pages.length < 2 ) {
                    throw new Error( 'Failed to determine page links!' );
                }
                pages = pages[1].replace( /['"]/g, '' ).split( ',' );
                if( !pages || pages.length < 1 ) {
                    throw new Error( 'No pages found!' );
                }
                // remove empty entries
                let pageList = pages.filter( p => p ).map( ( page ) => {
                    return ( path[1].indexOf('/') === 0 ? this.url : '' ) + path[1] + id[1] + '/' + page;
                } );
                callback( null, pageList );
            } )
            .catch( error => {
                console.error( error, chapter );
                callback( error, undefined );
            } );
        }
    }

</script>