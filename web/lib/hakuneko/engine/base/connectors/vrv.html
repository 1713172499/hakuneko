<link rel="import" href="../connector.html">

<script>

    /**
     * Base class for all VRV channels
     */
    class VRV extends Connector {

        /**
         *
         */
        constructor() {
            super();
            // Public members for usage in UI (mandatory)
            //super.id       = 'vrv';
            //super.label    = 'VRV Premium*';
            super.isLocked   = false;
            this.initialized = false;
            // Private members for internal usage only (convenience)
            this.api         = {
                base: 'https://api.vrv.co',
                core: 'https://api.vrv.co/core',
                cms: undefined,
                public: undefined,
                private: undefined
            };
            this.subscriptionID = 'vrv';
            this.subscription = false;
            this.regionBlock  = true;
            this.policies     = [];
            this.oauth        = OAuth( {
                consumer: {
                    key: 'OvqR158Z9212i41UkNRzooutpU9Vp0vuXD9K0zKAvJdXPh6LfMOro4stVQRS',
                    secret: 'EBgJav6Z99M9jFLzcexL6iETovNGbobFAJGudkDKMloqaBJgdo9u3WNuumM1'
                },
                signature_method: 'HMAC-SHA1',
                hash_function: ( data, key ) => {
                    return CryptoJS.HmacSHA1( data, key ).toString( CryptoJS.enc.Base64 );
                }
            } );
            this.oauthTtoken  = undefined;
            // Private members for internal use that can be configured by the user through settings menu (set to undefined or false to hide from settings menu!)
            this.config         = {
                username: {
                    label: 'E-Mail',
                    description: 'E-Mail for login with VRV premium account.\nDisclaimer: HakuNeko may drop support for VRV at any time.',
                    input: Input.text,
                    value: ''
                },
                password: {
                    label: 'Password',
                    description: 'Password for login with VRV premium account.\nDisclaimer: HakuNeko may drop support for VRV at any time.',
                    input: Input.password,
                    value: ''
                }
            };

            // Various other initilaizations ...
            document.addEventListener( EventListener.onSettingsChanged, this._onSettingsChanged.bind( this ) );
        }

        /**
         *
         */
        _getMangaList( callback ) {
            fetch( 'http://' + this.id + '.hakuneko.download/cdn/mangas.json', this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive serie list (status: ${response.status}) - ${response.statusText}` );
                }
                return response.json();
            } )
            .then( data => {
                callback( null, data );
            } )
            .catch( error => {
                console.error( error, this );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getChapterList( manga, callback ) {
            fetch( 'http://' + this.id + '.hakuneko.download/cdn/' + manga.id + '/chapters.json', this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive episode list (status: ${response.status}) - ${response.statusText}` );
                }
                return response.json();
            } )
            .then( data => {
                    let chapterList = [];
                    data.forEach( chapter => {
                        let prefix = '';
                        let season = ( chapter.volume ? 'S' + ( '0' + chapter.volume ).slice( -2 ) : '' );
                        let episode = ( chapter.number ? 'E' + ( '00' + chapter.number ).slice( -3 ) : '' );
                        prefix += season;
                        prefix += ( season.length > 0 && episode.length > 0 ? '.' : '' );
                        prefix += episode;
                        prefix += ( prefix.length > 0 ? ' - ' : '' );
                        chapter.pages.forEach( ( page ) => {
                            chapterList.push( {
                                id: chapter.id + '.' + page,
                                title: prefix + chapter.title + ' [' + page + 'p]',
                                language: chapter.language,
                                volume: chapter.volume,
                                number: chapter.number,
                                group: chapter.group,
                                pages: [ page ]
                            } );
                        } );
                    } );
                    chapterList.sort( ( a, b ) => {
                        if( a.volume !== b.volume ) {
                            return ( b.volume - a.volume );
                        }
                        if ( a.number !== b.number ) {
                            return ( b.number - a.number );
                        }
                        //return ( a.pages[0] > b.pages[0] ? 1 :-1 );
                        return ( parseInt( b.pages[0] ) - parseInt( a.pages[0] ) );
                    } );
                    callback( null, chapterList );
            } )
            .catch( error => {
                console.error( error, manga );
                callback( error, undefined );
            } );
        }

        /**
         *
         */
        _getPageList( manga, chapter, callback ) {
            let id;
            let resolution;
            ( new Promise( ( resolve, reject ) => {
                // FIXME: throw when country is not supported
                // FIXME: throw when not logged in but content of chapter is flagged as mature
                // FIXME: throw when not logged in or no premium subscription for channel but content of chapter is flagged as premium

console.log( 'REGION BLOCKED!', this.regionBlock );
if( this.regionBlock ) {
    throw new Error( 'Not available in your country!' );
}

                // get chapter info ...

                /*
                let authError = this._validateAuthorization();
                if( authError ) {
                    throw authError;
                }
                */
                let identifier = chapter.id.split( '.' );
                id = identifier[0];
                resolution = parseInt( identifier[1] );
                resolve();
            } ) )
            .then( () => {
console.log( 'GetEpisodes...', this.api.cms + '/episodes/' + id );
                return this._mergePolicyParams( this.api.cms + '/episodes/' + id )
                .then( href => fetch( href, this.requestOptions ) )
                .then( response => this._getResponseJSON( response ) );
            } )
            .catch( error => {
console.log( 'GetMovies...' );
                return this._mergePolicyParams( this.api.cms + '/movies/' + id )
                .then( href => fetch( href, this.requestOptions ) )
                .then( response => this._getResponseJSON( response ) );
            } )
            .then( data => {
if( data.is_mature && !this.oauthTtoken ) {
    throw new Error( 'This content is flagged as mature!\nYou need to be logged in with your account to view this content.' );
}
if( data.is_premium_only && !this.subscription ) {
    throw new Error( 'This content is flagged as premium!\nYou need to be logged in with your account\nand have a subscription to view this content.' );
}
                let streamsURL = ( data.__links__.streams ? this.api.base + data.__links__.streams.href : undefined );
                return this._getMedia( streamsURL, resolution );
            } )
            .then( data => {
console.log( 'CALLBACK', data );
                callback( null, data );
            } )
            .catch( error => {
                console.error( error, chapter );
                callback( error, undefined );
            } );
        }

        /**
         * 
         */
        _getMedia( url, resolution ) {
            return this._mergePolicyParams( url )
            .then( href => fetch( href, this.requestOptions ) )
            .then( response => this._getResponseJSON( response ) )
            .then( data => {
                let subtitles = Object.keys( data.subtitles ).map( key => data.subtitles[key] );
                let link = ( data.streams.adaptive_hls[''] ? data.streams.adaptive_hls[''].url : data.streams.adaptive_hls['en-US'].url );
                return this._getPlaylistURL( link, resolution )
                .then( playlist => {
                    return Promise.resolve( { playlist: playlist, subtitles: subtitles } );
                } );
            } );
        }

        /**
         * 
         */
        _getPlaylistURL( url, resolution ) {
            return fetch( url, this.requestOptions )
            .then( response => {
                if( response.status !== 200 ) {
                    throw new Error( `Failed to receive playlist (status: ${response.status}) - ${response.statusText}` );
                }
                return response.text();
            } )
            .then( data => {
                // TODO: use .filter and .map() instead of for-loop?
                let streams = [];
                let entries = data.split( '#EXT-X-STREAM-INF:' );
                for( let entry of entries ) {
                    entry = entry.trim();
                    if( entry.indexOf( 'RESOLUTION' ) > -1 ) {
                        let lines = entry.split( '\n' );
                        let resolution = lines[0].trim().match( /RESOLUTION=(\d+)x(\d+),/i );
                        streams.push( {
                            height: parseInt( resolution[2] ),
                            playlist: lines[1].trim()
                        } );
                    }
                }
                // find playlist for stream with desired resolution and pick the first available mirror ...
                streams.sort( ( a, b ) => {
                    if( a.height !== b.height ) {
                        return ( a.height - b.height );
                    } else {
                        return ( a.mirror > b.mirror ? 1 : -1 );
                    }
                } );
                // TODO: use random mirror for load balancing?
                let stream = streams.find( ( s ) => {
                    return ( s.height >= resolution );
                } ) || streams[streams.length-1];
                return Promise.resolve( stream.playlist );
            } );
        }

        /**
         * 
         */
        _onSettingsChanged( e ) {
            this._login( this.config.username.value, this.config.password.value )
            .catch( error => {
                console.warn( this.label + ' login failed!', error );
                return Promise.resolve();
            } )
            .then( () => this._init() )
            .catch( error => {
                console.warn( this.label + ' initialization failed!', error );
            } );
        }

        /**
         * 
         */
        /*
        _validateAuthorization() {
            if( this.regionBlock ) {
                return new Error( 'VRV service is not available in your country!' );
            }
            if( !this.subscription ) {
                return new Error( `In order to access the content, a paid VRV (${this.subscriptionID} channel) subscription is required!\nDisclaimer: HakuNeko may drop support for VRV at any time.` );
            }
            return null;
        }
        */

        /**
         * 
         */
        _getResponseJSON( response ) {
            if( response.status === 403 ) {
                this._logout();
            }
            return response.json()
            .then( data => {
                if( response.status !== 200 ) {
                    if( data.__class__ === 'error' ) {
                        throw new Error( /*'[' + data.code + '] ' +*/ data.type + ': ' + data.message )
                    } else {
                        throw new Error( `${response.status} - ${response.statusText} => No additional error information available!` );
                    }
                }
                return Promise.resolve( data );
            } );
        }

        /**
         * Append additional search parameters to the given URL based on the assigned policy rules.
         */
        _mergePolicyParams( url ) {
            try {
console.log( 'PolicyURL:', url );
                let uri = new URL( url );
                let path = uri.pathname;
                this.policies.filter( policy => {
                    let regex = new RegExp( '^' + policy.path.replace( /\*/g, '.' ) );
                    return regex.test( path );
                } ).forEach( policy => {
                    uri.searchParams.append( policy.name, policy.value );
                } );
                return Promise.resolve( uri.href );
            } catch( error ) {
                console.error( error, this.policies );
                return Promise.reject( error );
            }
        };

        /**
         * oAuth signature is based on method, url and GET/POST parameters
         * => https://developer.twitter.com/en/docs/basics/authentication/guides/creating-a-signature.html
         */
        _oauthRequest( oauthRequest ) {
            try {                
                this.requestOptions.method = oauthRequest.method;
                if( oauthRequest.method.toLowerCase() === 'post' ) {
                    /*
                    this.requestOptions.body = Object.keys( oauthRequest.data ).reduce( ( form, key ) => {
                        form.append( key, oauthRequest.data[key] );
                        return form;
                    }, new FormData() );
                    */
                    // FormData does not play along with oAuth ... => use base URLSearchPArmeters and set header manually
                    this.requestOptions.body = Object.keys( oauthRequest.data ).reduce( ( params, key ) => {
                        params.append( key, oauthRequest.data[key] );
                        return params;
                    }, new URLSearchParams() ).toString();
                    this.requestOptions.headers.set( 'content-type' , 'application/x-www-form-urlencoded' );
                }
                let oauthHeaders = this.oauth.toHeader( this.oauth.authorize( oauthRequest, this.oauthTtoken ) );
                this.requestOptions.headers.set( 'authorization' , oauthHeaders['Authorization'] );

                // NOTE: vrv blocks any request with forwarded ip address header
                let promise = fetch( oauthRequest.url, this.requestOptions );

                // finally: reset request options before returning promise ...
                this.requestOptions.headers.delete( 'authorization' );
                this.requestOptions.headers.delete( 'content-type' );
                delete this.requestOptions.body;
                this.requestOptions.method = 'GET';

                return promise;
            } catch( error ) {
                return Promise.reject( error );
            }
        }

        /**
         * Login to vrv website with username and password from settings to
         * get full access to all series.
         */
        _login( username, password ) {
            return new Promise( ( resolve, reject ) => {
                this._logout();
                if( typeof( username ) === 'string' && username !== '' && typeof( password ) === 'string' && password !== '' ) {
                    resolve( {
                        email: username,
                        password: password
                    } );
                } else {
                    throw new Error( 'No login credentials provided!' );
                }
            } )
            .then( form => {
                let oauthRequest = {
                    method: 'POST',
                    url: this.api.core + '/authenticate/by:credentials',
                    data: form
                };
                return this._oauthRequest( oauthRequest );
            } )
            .then( response => this._getResponseJSON( response ) )
            .then( data => {
                this.oauthTtoken = {
                    key: data.oauth_token,
                    secret: data.oauth_token_secret
                };
                return Promise.resolve();
            } );
        }

        /**
         * 
         */
        _logout() {
            this.oauthTtoken = undefined;
            this.api.cms = undefined;
            this.api.public = undefined;
            this.api.private = undefined;
            this.subscription = false;
            this.regionBlock = true;
        }

        /**
         * 
         */
        _init() {
            try {
                if( this.api.cms && this.api.public && this.api.private ) {
                    this.initialized = undefined;
                    return Promise.resolve( this.initialized );
                }
                // requires US proxy
                let oauthRequest = {
                    method: 'GET',
                    url: this.api.core + '/index',
                    data: {}
                };
                return this._oauthRequest( oauthRequest )
                .then( response => this._getResponseJSON( response ) )
                .then( data => {
                    // FIXME: path should use /v2/ instead of /v1/ for non-registered users ...
                    this.api.cms = this.api.base + data.__links__.cms_index.href.replace( /\/index$/, '' );
                    this.api.cms = this.api.base + data.__links__['cms_index.v2'].href.replace( /\/index$/, '' );
                    this.api.public = this.api.base + data.__links__.disc_index_unsigned.href.replace( /\/index$/, '' ).replace( '/private/', '/public/' ).replace( /\/\d+$/, '/-');
                    this.api.private = this.api.base + data.__links__.disc_index_unsigned.href.replace( /\/index$/, '' );
                    this.policies = data.signing_policies;
                    // verify if premium access is granted
                    this.subscription = ( this.api.private.indexOf( this.subscriptionID ) > -1 );
                    this.regionBlock = !data.service_available;
                    this.initialized = true;
                    console.log( 'API:', this.api.core + '/index', this.api );
                    return Promise.resolve( this.initialized );
                } );
            } catch( error ) {
                return Promise.reject( error );
            }
        }
    }

</script>