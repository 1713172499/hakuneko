<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="engine/base/enums.html">
<link rel="import" href="engine/loader.html">
<link rel="import" href="status.html">
<link rel="import" href="theme.html">

<dom-module id="hakuneko-chapters">

    <template>
        <style include="theme"></style>
        <style>
            :host {
                display: flex;
                flex-direction: column;
                padding: 0.5em;
                background-color: var(--chapter-control-background-color);
            }
            .separator {
                border-bottom: var(--chapter-control-separator);
            }
            .header {
                flex: 0;
                font-weight: bold;
                font-size: 1.25em;
                padding: 0.25em;
            }
            .filter {
                flex: 0;
                width: 100%;
            }
            .list {
                flex: 1;
                margin-top: 0.5em;
                margin-bottom: 0.5em;
                border: var(--chapter-list-border);
                background-color: var(--chapter-list-background-color);
                overflow-y: scroll;
                white-space: nowrap;
                list-style-type: none;
                padding: 0.25em;
            }
            .list li {
                overflow-x: hidden;
                text-overflow: ellipsis;
            }
            .list li:hover {
                background-color: var(--chapter-list-highlighted);
            }
            .focus {
                background-color: var(--chapter-list-selected) !important;
            }
            .button {
                cursor: pointer;
            }
            .buttonAvailable {
                color: var(--chapter-button-available-color);
            }
            .buttonQueued {
                color: var(--chapter-button-queued-color);
            }
            .buttonDownloading {
                color: var(--chapter-button-downloading-color);
            }
            .buttonCompleted {
                color: var(--chapter-button-completed-color);
            }
            .buttonFailed {
                color: var(--chapter-button-failed-color);
            }
            .footer {
                flex: 0;
            }
        </style>
        <div class="header separator">Chapter List</div>
        <table class="filter separator">
            <tr>
                <td>
                    <i class="fa fa-fw fa-language" title="Select a language to filter the chapter list"></i>
                </td>
                <td>
                    <select id="languageSelection" value="{{ searchLanguage::change }}">
                        <option value="">*</option>
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                    </select>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>
                    <i class="fa fa-fw fa-search" title="Enter a pattern to filter the chapter list by their titles"></i>
                </td>
                <td style="width: 100%;">
                    <input type="text" value="{{ searchPattern::input }}"/>
                </td>
                <td></td>
            </tr>
        </table>
        <!-- preformance of <ul> is way better than <select> in chromium browser for large lists (thousands of children) -->
        <ul class="list" >
            <template is="dom-repeat" items="[[ chapterList ]]" filter="[[ filterChapters(searchPattern, searchLanguage) ]]" rendered-item-count="{{ chapterFilteredCount }}" initial-count="500" target-framerate="5">
                <li class$="[[ getChapterClass(selectedChapter, item.id) ]]">
                    <i class$="fa fa-fw button [[ getChapterDownloadClass(item.status) ]]" on-click="processChapter" title$="[[ getChapterDownloadTooltip(item.status) ]]"></i>
                    <i class="fa fa-fw fa-picture-o button" style$="[[ getPagePreviewStyle(readerEnabled) ]]" on-click="selectChapter" title="Show preview of chapter's pages"></i>
                    <span class$="[[ item.status ]]" title$="[[ item.title ]]">[[ item.title ]]</span>
                </li>
            </template>
        </ul>
        <div class="footer">
            <hakuneko-status id="status" message="Chapters: [[ chapterFilteredCount ]] / [[ chapterList.length ]]"></hakuneko-status>
        </div>
    </template>

    <script>
        /** @polymerElement */
        class HakunekoChapters extends Polymer.Element {
            /**
             *
             */
            static get is() {
                return 'hakuneko-chapters';
            }

            /**
             *
             */
            static get properties() {
                return {
                    selectedConnector: {
                        type: Object,
                        value: undefined,
                        observer: 'onSelectedConnectorChanged'
                    },
                    selectedManga: {
                        type: Object,
                        value: undefined,
                        observer: 'onSelectedMangaChanged'
                    },
                    selectedChapter: {
                        type: Object,
                        notify: true,
                        value: undefined,
                        observer: 'onSelectedChapterChanged'
                    }
                };
            }

            /**
             *
             */
            ready() {
                super.ready();
                // 
                this.readerEnabled = Engine.Settings.readerEnabled;
                // list of all available chapters
                this.chapterList = undefined;
                // register callbacks for published events
                document.addEventListener( EventListener.onSettingsChanged, this.onSettingsChanged.bind( this ) );
                document.addEventListener( EventListener.onChapterStatusChanged, this.onChapterStatusChanged.bind( this ) );
            }

            /**
             * Observer will be executed, whenever the 'selectedConnector' is changed.
             */
            onSelectedConnectorChanged( connector ) {
                //console.log( connector.id );
                this.set( 'selectedChapter', undefined );
            }

            /**
             * Observer will be executed, whenever the 'selectedConnector' is changed.
             */
            onSelectedMangaChanged( manga ) {
                this.set( 'selectedChapter', undefined );
                if( !this.selectedConnector || !manga ) {
                    this.set( 'chapterList', undefined );
                    return;
                }
                let statusID = this.$.status.addToQueue( 'Loading chapter list (' + manga.title + ')' );
                manga.getChapters( ( error, chapters ) => {
                    // only apply chapters when selected manga has not changed
                    if( manga === this.selectedManga ) {
                        this.set( 'chapterList', chapters );
                    }
                    this.$.status.removeFromQueue( statusID );
                });
            }

            /**
             *
             */
            getChapterClass( selectedChapter, id ) {
                return ( !selectedChapter || selectedChapter.id !== id ? '' : 'focus' );
            }

            /**
             *
             */
            getChapterDownloadTooltip( status ) {
                switch ( status ) {
                    case DownloadStatus.unavailable:
                        return 'Chapter is not available';
                    case DownloadStatus.available:
                        return 'AVAILABLE\nClick to download chapter';
                    case DownloadStatus.queued:
                        return 'QUEUED\nClick to remove chapter from download manager';
                    case DownloadStatus.downloading:
                        return 'DOWNLOADING';
                    case DownloadStatus.completed:
                        return 'DOWNLOADED\nClick to delete and re-download chapter';
                    case DownloadStatus.failed:
                        return 'DOWNLOAD FAILED\nClick to delete and re-download chapter';
                    default:
                        return 'No tooltip available!';
                }
            }

            /**
             *
             */
            getChapterDownloadClass( status ) {
                switch ( status ) {
                    case DownloadStatus.unavailable:
                        return 'fa-exclamation-triangle';
                    case DownloadStatus.available:
                        return 'fa-cloud buttonAvailable';
                    case DownloadStatus.queued:
                        return 'fa-cloud-download buttonQueued';
                    case DownloadStatus.downloading:
                        return 'fa-cloud-download buttonDownloading';
                    case DownloadStatus.completed:
                        return 'fa-folder-open buttonCompleted';
                    case DownloadStatus.failed:
                        return 'fa-exclamation-triangle buttonFailed';
                    default:
                        return '';
                }
            }

            /**
             *
             */
            getPagePreviewStyle( readerEnabled ) {
                return ( readerEnabled ? '' : 'display: none;' );
            }

            /**
             *
             */
            processChapter( e ) {
                let chapter = e.model.item;
                switch ( chapter.status ) {
                    case DownloadStatus.unavailable:
                        alert( 'No action available!' );
                        break;
                    case DownloadStatus.available:
                        Engine.DownloadManager.addDownload( chapter );
                        break;
                    case DownloadStatus.completed:
                        if( confirm( 'Re-Download?' ) ) {
                            Engine.DownloadManager.addDownload( chapter );
                        }
                        break;
                    case DownloadStatus.failed:
                        alert( 'No action available!' );
                        /*
                        if( confirm( 'Re-Download?' ) ) {
                            alert( 'TODO: ...' );
                        }
                        */
                        break;
                    default:
                        alert( 'No action available!' );
                        break;
                }
            }

            /**
             * Select a chapter => this will trigger the pages to be viewed.
             */
            selectChapter( e ) {
                if( !e.model || !e.model.item ) {
                    return;
                }
                this.set( 'selectedChapter', e.model.item );
            }

            /**
             * Observer will be executed, whenever the 'selectedChapter' is changed.
             */
            onSelectedChapterChanged( chapter ) {
                //
            }

            /**
             *
             */
            filterChapters( pattern, language ) {
                if( ( !pattern || pattern.length < 1 ) && ( !language || language.length < 1 ) ) {
                    return null;
                }
                return ( chapter ) => {
                    let matchTitle = !pattern || ( chapter.title.toLowerCase().indexOf( pattern.toLowerCase() ) > -1 );
                    let matchLanguage = !language || ( chapter.language.toLowerCase().indexOf( language.toLowerCase() ) > -1 );
                    return ( matchTitle && matchLanguage );
                };
            }

            /**
             *
             */
            onSettingsChanged( e ) {
                this.readerEnabled = Engine.Settings.readerEnabled.value;
            }

            /**
             * 
             */
            onChapterStatusChanged( e ) {
                let chapter = e.detail;
                if( !this.chapterList
                    || !this.selectedManga
                    || !this.selectedConnector
                    || this.selectedManga.id !== chapter.manga.id
                    || this.selectedConnector.id !== chapter.manga.connector.id
                ) {
                    return;
                }
                let index = this.chapterList.findIndex( ( item ) => {
                    // chapters may be different objects (reloading chapter list) but still be the equivalent
                    // => comparing ids instead of comparing the objects directly
                    return ( item.id === chapter.id );
                });
                if( index > -1 ) {
                    this.notifyPath( 'chapterList.' + index + '.status' );
                }
            }
        }
        window.customElements.define( HakunekoChapters.is, HakunekoChapters );
    </script>

</dom-module>
